

class LanguagesEntity {
  String image;
  String title;
  String description;

  LanguagesEntity({
    required this.image,
    required this.title,
    required this.description,
  });
}

class FlutterEntity extends LanguagesEntity {
  Map<String, Map<String, CategoryDetail>?> entries;

  FlutterEntity({
    required this.entries,
    required super.image,
    required super.title,
    required super.description,
  });
}

class CategoryDetail {
  List<String> items;
  String description;

  CategoryDetail(this.items, this.description);
}

List<LanguagesEntity> listLanguages = [
  FlutterEntity(
      image: 'assets/images/FlutterImage.svg',
      title: 'Development with Flutter',
      description: 'Create cross-platform applications that are high-performing and have a flexible design.',
      entries: {
        'Среда разработки': {
          'Интегрированная среда разработки': CategoryDetail([
            'Android Studio',
            'VS Code'
          ], "IDE (Integrated Development Environment) — это программная среда, объединяющая множество инструментов для упрощения разработки и повышения продуктивности разработчиков. В контексте разработки на Flutter, IDE помогает быстро создавать, тестировать и отлаживать мобильные и веб-приложения, предлагая интеграцию с необходимыми библиотеками и пакетами.\n\nОсновные возможности IDE для Flutter:\n\nАвтозаполнение и подсказки\nПомогает разработчику быстрее писать код, предлагая варианты автодополнения и контекстные подсказки для Flutter и Dart.\n\nОтладка (Debugging)\nИнструменты для пошагового выполнения кода, просмотра значений переменных, и отслеживания ошибок в режиме реального времени.\n\nПостроение интерфейсов\nIDE, такие как Android Studio и VS Code, поддерживают функции предварительного просмотра, позволяя видеть, как будет выглядеть интерфейс на реальном устройстве.\n\nУправление проектом и сборками\nВключает управление зависимостями, сборку проекта, управление версиями и инструменты для развертывания.\n\nИнтеграция с эмуляторами и устройствами\nПозволяет запускать приложения на эмуляторах Android и iOS, а также на подключенных реальных устройствах для тестирования.\n\nПопулярные IDE для Flutter:\n\nAndroid Studio: IDE от Google с полноценной поддержкой Flutter и мощным набором инструментов.\nVisual Studio Code (VS Code): Легкая и расширяемая IDE, поддерживающая Flutter через плагины."),
          'Набор инструментов Flutter': CategoryDetail([
            'Flutter CLI (командная строка Flutter)'
          ], 'Flutter SDK — это комплект инструментов для разработки приложений на Flutter, созданный Google. SDK (Software Development Kit) предоставляет все необходимое для написания, тестирования и сборки кроссплатформенных приложений, работающих на Android, iOS, веб и настольных платформах.\n\nОсновные компоненты Flutter SDK:\n\nФреймворк Flutter\nСодержит набор виджетов (widgets), компонентов для построения интерфейсов, а также утилиты и библиотеки, которые позволяют создавать приложения с единой кодовой базой для разных платформ.\n\nКомпилятор Dart\nFlutter использует язык программирования Dart, и компилятор в составе SDK позволяет преобразовывать код Dart в нативный машинный код для повышения производительности приложений.\n\nИнструменты командной строки\nНабор команд (например, flutter run, flutter build, flutter doctor) для управления проектом, его сборки и развертывания. Команды позволяют также диагностировать проблемы с зависимостями и настройками среды разработки.\n\nHot Reload и Hot Restart\nЭти функции позволяют разработчику вносить изменения в код и сразу видеть результат в реальном времени, без необходимости полной перезагрузки приложения. Hot Reload обновляет состояние экрана без перезапуска, а Hot Restart — выполняет полную перезагрузку приложения, начиная с главного экрана.\n\nDevTools\nНабор инструментов для отладки и мониторинга производительности приложения, включая просмотр логов, анализ использования памяти и CPU, а также мониторинг рендеринга экрана.\n\nПлагины и пакеты\nSDK поддерживает сторонние библиотеки и плагины, что позволяет интегрировать в приложение такие функции, как доступ к камере, геолокации, сети, базам данных и многому другому.')
        },
        'Основы Dart': {
          'Переменные': CategoryDetail(
              [
                'int (целое число)',
                'double (число с плавающей запятой)',
                'String (строка)',
                'Bool (логическое значение)',
                'List (Список/Лист)',
                'Map (словарь)',
                'Set (множество уникальных значений)',
                'Var (переменная)',
                'Dynamic (динамический тип)',
                'Const (константа)',
                'Final (неизменяемая переменная)',
                'Runes (руны)',
                'Symbol (символ)',
              ],
              'Переменные и типы данных\nПеременная - это место хранения данных, а типы данных - это тип и размер данных, связанных с переменными и функциями.\nДля объявления переменной в Dart используется ключевое слово var. Синтаксис переменной var приведен ниже,\nvar name = '
              'Dart'
              ';\nКлючевое слово final и const используются для объявления констант. Они определяются следующим образом:\n\nvoid main() {\nfinal a = 12;\nconst pi = 3.14;\nprint(a); print(pi);\n}\n\nЯзык Dart поддерживает следующие типы данных:\nЧисла: Используется для представления числовых литералов - Integer и Double.\nСтроки: Представляют собой последовательность символов. Значения строк указываются в одинарных или двойных кавычках.\nБулевы: В Dart используется ключевое слово bool для представления булевых значений - true и false.\nСписки и карты: Используются для представления коллекции объектов. Простой список можно определить следующим образом:\n\nvoid main() {\nvar list = [1,2,3,4,5];\nprint(list);\n}\n\nИз приведенного выше списка получается список [1,2,3,4,5].\nКарта может быть определена, как показано здесь:\n\nvoid main() {\nvar mapping = {'
              'id'
              ': 1,'
              'name'
              ':'
              'Dart'
              '};\nprint(mapping);\n}\n\nДинамический: если тип переменной не определен, то по умолчанию она имеет динамический тип. Следующий пример иллюстрирует переменную динамического типа:\n\nvoid main() {\ndynamic name = "Dart";\nprint(name);\n}'),
          'Функции': CategoryDetail(
              [
                'Regular (Регулярный)',
                'Void (пустой тип)',
                'Anonymous Functions (Анонимные функции)',
                'Arrow Functions (Стрелочные функции)',
                'Higher-Order Functions (Функции высшего порядка)',
                'Async Functions (Асинхронные функции)',
                'Generator Functions (Функции-генераторы)',
              ],
              'Функции в Dart — это самостоятельные блоки кода, которые выполняют определенные действия. Они позволяют организовывать код, повторно использовать его и повышать его читаемость. В Dart функции могут принимать аргументы, возвращать значения и даже быть переданы как объекты.\n\nОпределение функции: Функция в Dart определяется с использованием ключевого слова void (если она не возвращает значение) или с указанием типа возвращаемого значения. Синтаксис выглядит следующим образом:\n\nReturnType functionName(ParameterType parameterName) {\n // Тело функции\n}\nПример:\n\nint add(int a, int b) {\n return a + b;\n}\n\nТипы функций:\n\n1. Обычные функции:\nОпределяются с помощью имени и могут быть вызваны в любом месте программы.\nПример:\n\nvoid greet(String name) {\n print('
              'Hello, \$name!'
              ');\n}\n\n2. Анонимные функции (лямбды):\nНе имеют имени и могут быть присвоены переменным.\nПример:\n\nvar multiply = (int a, int b) => a * b;\n\n3. Функции высшего порядка:\nМогут принимать функции в качестве аргументов или возвращать их.\nПример:\n\nvoid performOperation(int a, int b, Function operation) {\n print('
              'Результат: \${operation(a, b)}'
              ');\n}\n\n4. Функции с именованными параметрами:\nПозволяют передавать аргументы в любом порядке.\nПример:\n\nvoid createAccount({String? username, String? email}) {\n // Логика создания аккаунта\n}\n\n5. Функции с необязательными параметрами:\nОпределяются с использованием квадратных скобок.\nПример:\n\nvoid printInfo(String name, [int? age]) {\n print('
              'Name: \$name, Age: \${age ?? '
              'неизвестно'
              '}'
              ');\n}\n\n значений: Функции могут возвращать значения, которые можно использовать в других частях программы. Если функция не возвращает значения, используется тип void.\n\nПример с возвратом значения:\n\nString getFullName(String firstName, String lastName) {\n return '
              '\$firstName \$lastName'
              ';\n}\n\nСтатические и экземплярные методы: В Dart функции также могут быть определены как методы внутри классов. Методы могут быть статическими (принадлежат классу) или экземплярными (принадлежат экземпляру класса).\n\nПример метода в классе:\n\nclass Calculator {\n int add(int a, int b) {\n return a + b;\n }\n}.'),
          'Операторы': CategoryDetail([
            'Arithmetic Operators (Арифметические операторы)',
            'Equality and Relational Operators (Операторы равенства и отношения)',
            'Type Test Operators (Операторы проверки типа)',
            'Assignment Operators (Операторы присваивания)',
            'Logical Operators (Логические операторы)',
            'Bitwise Operators (Побитовые операторы)',
            'Conditional (Ternary) Operator (Условный (тернарный) оператор)',
            'Cascade Operator (Оператор каскадирования)',
            'Null-aware Operators (Операторы, учитывающие null)'
          ], 'Операторы в Dart — это специальные символы, которые выполняют операции над переменными и значениями. Dart поддерживает различные типы операторов, включая арифметические, логические, битовые, реляционные и оператор присваивания. Использование операторов позволяет создавать более компактный и читаемый код.'),
          'Операторы управления': CategoryDetail([
            'if (Если)',
            'else (Иначе)',
            'else if (Иначе если)',
            'switch (оператор выбора)',
            'case (случай)',
            'default (значение по умолчанию)',
            'for (цикл для итерации)',
            'while (пока)',
            'do-while (выполнять пока)',
            'break (выход из цикла)',
            'continue (продолжить)',
            'return (возврат значения)',
            'try (попытка обработки)',
            'catch (перехват исключения)',
            'finally (блок завершения)',
            'throw (генерация исключения)',
            'rethrow (повторная генерация исключения)',
          ], 'Управляющие конструкции в Dart позволяют управлять порядком выполнения кода в зависимости от условий или повторяющихся операций. Они помогают реализовать логику принятия решений и обработки ошибок.\n\n1. Условные операторы\nУсловные операторы используются для выполнения определенного кода в зависимости от выполнения условия.\n\n*if и else Условный оператор if выполняет блок кода, если условие истинно. Блок else выполняется, если условие ложно.\n*else if Позволяет проверять несколько условий.\n*switch Оператор switch используется для выбора одного из множества вариантов в зависимости от значения переменной.\n*case (случай) Обозначает вариант внутри switch, который будет выполнен, если переменная равна заданному значению.\n*default (значение по умолчанию) Блок кода, который выполняется, если ни одно из условий в switch не совпадает.\n\n2. Циклы\nЦиклы используются для повторения блока кода несколько раз.\n\n*for Цикл for выполняет блок кода фиксированное количество раз.\n*while Цикл while выполняет блок кода, пока условие истинно.\n*do while Цикл do while выполняет блок кода хотя бы один раз, а затем продолжает выполнение, пока условие истинно.\n\n3. Управляющие операторы\n*break Оператор break используется для выхода из цикла или оператора switch.\n*continue Оператор continue пропускает текущую итерацию цикла и переходит к следующей.\n*return (возврат значения) Используется для возврата значения из функции.\n\n4. Обработка исключений\n*try (попытка обработки) Используется для оборачивания кода, который может вызвать исключение.\n*catch (перехват исключения) Обрабатывает исключение, если оно было выброшено в блоке try.\n*finally (блок завершения) Блок кода, который выполняется после try и catch, независимо от того, было ли выброшено исключение.\n*throw (генерация исключения) Используется для явного выбрасывания исключения.\n*rethrow (повторная генерация исключения) Позволяет повторно выбросить перехваченное исключение.')
        },
        'Виджеты': {
          'Статические виджеты без состояния': CategoryDetail([
            'Text (Текст)',
            'Icon (Иконка)',
            'Image (Изображение)',
            'Container (Контейнер)',
            'Column (Столбец)',
            'Row (Строка)',
            'Stack (Стек)',
            'Center (Центр)',
            'Padding (Отступ)',
            'Align (Выравнивание)',
            'Sized Box (Размеренный контейнер)',
            'Spacer (Пробел между)',
            'Divider (Разделитель)',
            'Placeholder (Заполнитель)',
            'Card (Карточка)',
          ], 'StatelessWidget в Flutter представляет собой виджет, который не изменяет свое состояние во время жизненного цикла. Он отображает фиксированное значение, которое определяется в момент создания. Если требуется изменить отображение, необходимо создать новый экземпляр виджета с новыми данными.\nПреимущества Stateless Widgets\nПростота: Stateless виджеты легче в понимании и использовании, так как их поведение не изменяется.\nПроизводительность: Они менее ресурсоемкие по сравнению с StatefulWidget, так как не требуют управления состоянием.\nУдобство: Идеальны для простых и статических интерфейсов, таких как текстовые метки, иконки и статические карточки.'),
          'Динамические виджеты с сохранением состояния': CategoryDetail([
            'TextField (Текстовое поле)',
            'Checkbox (Флажок)',
            'Radio (Переключатель(радиокнопка))',
            'Switch(Переключатель(тумблер))',
            'Slider (Слайдер (ползунок))',
            'Form (Форма)',
            'AnimatedContainer (Анимированный контейнер)',
            'ListView (Прокручиваемый список)',
            'FutureBuilder',
            'StreamBuilder',
            'GestureDetector (Обнаружение жестов)',
            'Draggable (Перетаскиваемый элемент)',
            'BottomNavigationBar (Нижняя панель навигации)',
            'TabBar (Панель вкладок)',
          ], 'StatefulWidget в Flutter — это тип виджета, который может изменять свое состояние во время жизненного цикла. Это делает его подходящим для отображения данных, которые могут динамически изменяться (например, счетчики, анимации, формы и другие элементы, которые требуют обновления интерфейса).'),
          'Унаследованные виджеты': CategoryDetail([
            'InheritedWidget (унаследованный виджет)',
            'InheritedModel (унаследованная модель)',
            'MediaQuery ( Информация о медиа-характеристиках устройства)',
            'Theme (тема)',
            'Navigator (навигатор)',
            'MaterialApp (Приложение на основе Material Design)',
            'CupertinoApp (Приложение на основе iOS-стиля (Cupertino))',
            'Provider (from the Provider package) (Провайдер из пакета Provider)',
            'InheritedNotifier (унаследованный уведомитель)',
            'StreamProvi﻿der (from the Provider package) (Stream-провайдер из пакета Provider)',
            'FuturePr﻿ovider (from the Provider package) (Future-провайдер из пакета Provider)',
          ], 'InheritedWidget — это специальный тип виджета в Flutter, который позволяет передавать данные по дереву виджетов без необходимости напрямую передавать их через конструкторы. InheritedWidget предоставляет доступ к данным для всех дочерних виджетов, что делает его отличным выбором для управления состоянием, которое должно быть доступно многим виджетам в приложении.\nПринцип работы InheritedWidget\n\tОсновное назначение InheritedWidget — это предоставить данные или объекты состояния, которые могут быть доступны по дереву виджетов ниже. Когда данные в InheritedWidget изменяются, все виджеты, зависящие от этого состояния, автоматически пересоздаются для обновления интерфейса.'),
          'Адаптивные виджеты': CategoryDetail([
            'MediaQuery ( Информация о медиа-характеристиках устройства)',
            'LayoutBuilder (строитель макета)',
            'Flexible (гибкий)',
            'Expanded (расширенный)',
            'AspectRatio (соотношение сторон)',
            'FittedBox (вписанный виджет)',
            'ResponsiveBuilder (from the responsive_builder package) (ResponsiveBuilder из пакета responsive_builder)',
            'ScreenUtil (from the flutter_screenutil package) (ScreenUtil из пакета flutter_screenutil)',
            'SizedBox (размеренный виджет)',
            'OrientationBuilder (строитель ориентации)',
            'GridView (сетчатый виджет)',
            'ListView (виджет списка)',
            'Wrap (обертка)',
            'Column (столбец)',
            'Row (строка)',
          ], 'Responsive Widgets в Flutter предназначены для создания интерфейсов, которые адаптируются под разные размеры экранов, ориентации и плотность пикселей. Этот подход позволяет обеспечить удобный и корректный вид приложения на разных устройствах, от маленьких телефонов до планшетов и больших экранов.\n\nОсновные методы создания адаптивного интерфейса\n1. LayoutBuilder: Используется для создания виджетов на основе размеров родительского контейнера. Это полезно для создания адаптивного интерфейса в зависимости от текущей ширины экрана.\n2. MediaQuery: Предоставляет информацию о размере экрана, ориентации и других характеристиках устройства. С помощью MediaQuery можно менять структуру интерфейса на основе данных устройства.\n3. Flexible и Expanded: Эти виджеты позволяют дочерним элементам занимать оставшееся пространство в контейнере, что помогает обеспечить адаптивность. Flexible позволяет элементу адаптироваться к доступному пространству, а Expanded занимает все доступное пространство.\n4. AspectRatio: Устанавливает соотношение сторон для виджета, сохраняя пропорции на разных размерах экранов.\n5. OrientationBuilder: Изменяет интерфейс в зависимости от ориентации экрана (портретной или ландшафтной).\n6. FittedBox (Вписанный виджет): Масштабирует дочерний элемент до максимально возможного размера в пределах родительского контейнера, сохраняя пропорции.\n7. ResponsiveBuilder (из пакета responsive_builder): Упрощает создание адаптивных интерфейсов, автоматически подстраиваясь под разные экраны.\n8. ScreenUtil (из пакета flutter_screenutil): Позволяет устанавливать размеры и отступы, которые адаптируются к размеру экрана. Это полезно для обеспечения масштабируемости на разных устройствах.\n9. SizedBox (Размеренный виджет): Виджет для создания ограниченного пространства, который помогает задавать фиксированную ширину или высоту элемента.\n10. GridView (Сетчатый виджет): Виджет для создания прокручиваемой сетки элементов, что особенно полезно при создании галерей или таблиц.\n11. ListView (Виджет списка): Прокручиваемый список элементов, который полезен для отображения большого количества данных.\n12. Wrap (Обертка): Виджет, который автоматически переносит дочерние элементы на новую строку или столбец, если нет места в текущем ряду или столбце.\n13. Column (Столбец): Располагает элементы вертикально. Удобен для создания вертикальных компоновок.\n14. Row (Строка): Располагает элементы горизонтально, создавая структуру для горизонтальной компоновки.'),
          'Стилизованные Material виджеты': CategoryDetail([
            'MaterialApp (Приложение на основе Material Design)',
            'Scaffold (каркас)',
            'AppBar (панель приложения)',
            'Drawer (выдвижное меню)',
            'BottomNavigationBar (нижняя навигационная панель)',
            'FloatingActionButton (плавающая кнопка действия)',
            'Card (карточка)',
            'Chip (чип)',
            'Dialog (диалог)',
            'SnackBar (снэк-бар)',
            'IconButton (кнопка с иконкой)',
            'Tooltip (подсказка)',
            'TextButton (кнопка с текстом)',
            'ElevatedButton (высокая кнопка)',
            'OutlinedButton (кнопка с обводкой)',
          ], 'Styled Material Widgets — это набор виджетов в Flutter, которые используют стилизацию и тему Material Design для обеспечения согласованного интерфейса, поддерживая цвета, размеры и стили согласно дизайн-системе Google. С их помощью можно настраивать элементы интерфейса для соответствия вашему уникальному стилю, сохраняя знакомый пользователям опыт.\n\nОсновные виджеты и стили Material Design:\n1. MaterialApp (Приложение на основе Material Design): Корневой виджет приложения, предоставляющий темы и маршрутизацию. Настройка MaterialApp позволяет задать основную тему, маршруты, начальный экран и другие параметры, определяющие общий стиль приложения.\n2. Scaffold (Каркас): Базовый контейнер для экрана, обеспечивающий структуру и компоненты, такие как AppBar, Drawer, BottomNavigationBar, и FloatingActionButton. Scaffold задаёт основу для интерфейса, автоматически обрабатывая такие элементы, как клавиатура и прокрутка.\n3. AppBar (Панель приложения): Верхняя панель с заголовком, иконками и кнопками действий. Можно стилизовать цвет фона, тени, элементы, а также добавить логотип или иконку меню.\n4. Drawer (Выдвижное меню): Боковое меню навигации, которое можно открывать свайпом или с помощью иконки в AppBar. Drawer позволяет пользователям быстро переключаться между разделами приложения.\n5. BottomNavigationBar (Нижняя навигационная панель): Панель навигации в нижней части экрана, позволяющая пользователям переключаться между основными разделами приложения. Каждый элемент навигации может иметь иконку и подпись.\n6. FloatingActionButton (Плавающая кнопка действия): Круглая кнопка для основных действий на странице. Можно изменить цвет, иконку и форму.\n7. Card (Карточка): Контейнер с тенями и закруглёнными углами, применяемый для визуального отделения информации в списках, профилях или новостях. Card поддерживает стилизацию с заданием цвета и границ.\n8. Chip (Чип): Компактный элемент, используемый для отображения короткой информации, тегов или контактов. Чипы часто применяются для фильтров, иконок и текста в ограниченном пространстве.\n9. Dialog (Диалог): Всплывающее окно для отображения информации, подтверждений или запросов к пользователю. Dialog содержит элементы заголовка, основного текста и действий. Существуют несколько видов диалогов, таких как AlertDialog и SimpleDialog.\n10. SnackBar (Снэк-бар): Краткое уведомление, которое временно отображается внизу экрана. SnackBar используется для отображения сообщений о статусе или подтверждений действий.\n11. IconButton (Кнопка с иконкой): Кнопка, отображающая иконку вместо текста. Часто используется в AppBar для создания действий. IconButton можно стилизовать, задав цвет, размер и внешний вид иконки.\n12. Tooltip (Подсказка): Небольшое текстовое окно, которое появляется при долгом нажатии на элемент и отображает дополнительную информацию. Tooltip помогает объяснить действие или цель элементов интерфейса.\n13. TextButton (Кнопка с текстом): Кнопка без фона, содержащая только текст. Обычно применяется для вторичных действий и может быть стилизована с использованием цвета текста и эффектов.\n14. ElevatedButton (Приподнятая кнопка): Кнопка с приподнятым эффектом, настраиваемая по цвету фона, текста и форме.\n15. OutlinedButton (Кнопка с обводкой): Кнопка с контуром вместо фона, используется для менее акцентных действий. OutlinedButton может быть настроена с цветом контура и текста.'),
          'Стилизованные Cupertino виджеты': CategoryDetail([
            'CupertinoApp (Приложение на основе iOS-стиля (Cupertino))',
            'CupertinoNavigationBar (Cupertino-навигационная панель)',
            'CupertinoTabBar (Cupertino-вкладки)',
            'CupertinoButton (Cupertino-кнопка)',
            'CupertinoSlider (Cupertino-слайдер)',
            'CupertinoSwitch (Cupertino-переключатель)',
            'CupertinoScrollbar (Cupertino-скроллбар)',
          ], 'Набор виджетов Cupertino в Flutter создаёт интерфейсы, стилизованные под iOS. Эти виджеты помогают сделать ваше приложение более адаптированным к стилю и поведению iOS и идеальны для платформенно-ориентированного подхода.\n\nОсновные виджеты и стили Cupertino:\n1. CupertinoApp (Приложение на основе iOS-стиля): Основной виджет для создания приложения в стиле iOS. Похож на MaterialApp, но с настройками и стилями, характерными для iOS. Управляет навигацией, темами и локализацией.\n2. CupertinoNavigationBar (Cupertino-навигационная панель): Верхняя панель в стиле iOS для отображения заголовка и кнопок навигации. Можно стилизовать цвета и содержимое.\n3. CupertinoTabBar (Cupertino-вкладки): Нижняя панель вкладок в стиле iOS для переключения между разделами приложения. Можно стилизовать по цвету, размеру значков и тексту.\n4. CupertinoButton (Cupertino-кнопка): Кнопка, стилизованная для iOS, с настраиваемым цветом, текстом и размером.\n5. CupertinoSlider (Cupertino-слайдер): Слайдер для выбора значений в диапазоне. Стилизуется по цвету активной полоски и положению ползунка.\n6. CupertinoSwitch (Cupertino-переключатель): Переключатель, который позволяет включать или отключать опцию. Стилизуется по цвету активного состояния.\n7. CupertinoScrollbar (Cupertino-скроллбар): Полоса прокрутки в стиле iOS для улучшения навигации по длинным спискам. Виджет автоматически отображается при скроллинге и может быть стилизован.')
        },
        'Ассеты': {
          'Шрифты': CategoryDetail([],
              'Assets в Flutter — это файлы, используемые вашим приложением, такие как изображения, шрифты, звуки и другие ресурсы. Эти файлы загружаются в приложение и могут быть использованы для создания пользовательского интерфейса и взаимодействия.\n\nОсновные виды ассетов:\n1. Изображения: Изображения могут быть в форматах PNG, JPEG, GIF и других. Их можно использовать для отображения графики в приложении.\n2. Шрифты: Шрифты добавляются в проект для использования в текстовых виджетах. Можно включить пользовательские шрифты в приложение.\n3. Звуковые файлы: Звуковые файлы, такие как MP3 или WAV, могут быть добавлены для воспроизведения звуковых эффектов или музыки в приложении.\n4. Данные в формате JSON: JSON файлы могут использоваться для хранения и загрузки конфигураций, настроек или данных в приложении.'),
          'Изображения': CategoryDetail([],
              'Assets в Flutter — это файлы, используемые вашим приложением, такие как изображения, шрифты, звуки и другие ресурсы. Эти файлы загружаются в приложение и могут быть использованы для создания пользовательского интерфейса и взаимодействия.\n\nОсновные виды ассетов:\n1. Изображения: Изображения могут быть в форматах PNG, JPEG, GIF и других. Их можно использовать для отображения графики в приложении.\n2. Шрифты: Шрифты добавляются в проект для использования в текстовых виджетах. Можно включить пользовательские шрифты в приложение.\n3. Звуковые файлы: Звуковые файлы, такие как MP3 или WAV, могут быть добавлены для воспроизведения звуковых эффектов или музыки в приложении.\n4. Данные в формате JSON: JSON файлы могут использоваться для хранения и загрузки конфигураций, настроек или данных в приложении.'),
          'Другие файлы': CategoryDetail([],
              'Assets в Flutter — это файлы, используемые вашим приложением, такие как изображения, шрифты, звуки и другие ресурсы. Эти файлы загружаются в приложение и могут быть использованы для создания пользовательского интерфейса и взаимодействия.\n\nОсновные виды ассетов:\n1. Изображения: Изображения могут быть в форматах PNG, JPEG, GIF и других. Их можно использовать для отображения графики в приложении.\n2. Шрифты: Шрифты добавляются в проект для использования в текстовых виджетах. Можно включить пользовательские шрифты в приложение.\n3. Звуковые файлы: Звуковые файлы, такие как MP3 или WAV, могут быть добавлены для воспроизведения звуковых эффектов или музыки в приложении.\n4. Данные в формате JSON: JSON файлы могут использоваться для хранения и загрузки конфигураций, настроек или данных в приложении.')
        },
        'Гит': {
          'GitHub': CategoryDetail([],
              'Git — это распределённая система управления версиями, используемая для отслеживания изменений в исходном коде и координации работы над проектами. Git позволяет разработчикам работать совместно, сохранять историю изменений и восстанавливать предыдущие версии файлов.\n\nОсновные понятия Git:\n1. Репозиторий (Repository): Это место, где хранится весь проект, включая файлы, папки и историю изменений. Репозиторий может быть локальным (на вашем компьютере) или удалённым (например, на GitHub, GitLab и т. д.).\n2. Коммит (Commit): Это фиксированное состояние файлов в репозитории. Каждый коммит содержит сообщение, описывающее изменения, и уникальный идентификатор.\n3. Ветка (Branch): Ветка — это независимая линия разработки. Она позволяет вам работать над новыми функциями или исправлениями, не затрагивая основную (обычно main или master) ветку.\n4. Слияние (Merge): Слияние — это процесс объединения изменений из одной ветки в другую. Обычно сливаются изменения из ветки функции в основную ветку.\n5. Удалённый репозиторий (Remote Repository): Это версия вашего репозитория, размещённая на сервере. Вы можете взаимодействовать с удалённым репозиторием для совместной работы с другими разработчиками.\n6. Пулл (Pull): Команда, которая позволяет загрузить изменения из удалённого репозитория и объединить их с вашей локальной веткой.\n7. Пуш (Push): Команда, которая отправляет ваши локальные коммиты в удалённый репозиторий.'),
          'GitLab': CategoryDetail([],
              'Git — это распределённая система управления версиями, используемая для отслеживания изменений в исходном коде и координации работы над проектами. Git позволяет разработчикам работать совместно, сохранять историю изменений и восстанавливать предыдущие версии файлов.\n\nОсновные понятия Git:\n1. Репозиторий (Repository): Это место, где хранится весь проект, включая файлы, папки и историю изменений. Репозиторий может быть локальным (на вашем компьютере) или удалённым (например, на GitHub, GitLab и т. д.).\n2. Коммит (Commit): Это фиксированное состояние файлов в репозитории. Каждый коммит содержит сообщение, описывающее изменения, и уникальный идентификатор.\n3. Ветка (Branch): Ветка — это независимая линия разработки. Она позволяет вам работать над новыми функциями или исправлениями, не затрагивая основную (обычно main или master) ветку.\n4. Слияние (Merge): Слияние — это процесс объединения изменений из одной ветки в другую. Обычно сливаются изменения из ветки функции в основную ветку.\n5. Удалённый репозиторий (Remote Repository): Это версия вашего репозитория, размещённая на сервере. Вы можете взаимодействовать с удалённым репозиторием для совместной работы с другими разработчиками.\n6. Пулл (Pull): Команда, которая позволяет загрузить изменения из удалённого репозитория и объединить их с вашей локальной веткой.\n7. Пуш (Push): Команда, которая отправляет ваши локальные коммиты в удалённый репозиторий.'),
          'BitBucket': CategoryDetail([],
              'Git — это распределённая система управления версиями, используемая для отслеживания изменений в исходном коде и координации работы над проектами. Git позволяет разработчикам работать совместно, сохранять историю изменений и восстанавливать предыдущие версии файлов.\n\nОсновные понятия Git:\n1. Репозиторий (Repository): Это место, где хранится весь проект, включая файлы, папки и историю изменений. Репозиторий может быть локальным (на вашем компьютере) или удалённым (например, на GitHub, GitLab и т. д.).\n2. Коммит (Commit): Это фиксированное состояние файлов в репозитории. Каждый коммит содержит сообщение, описывающее изменения, и уникальный идентификатор.\n3. Ветка (Branch): Ветка — это независимая линия разработки. Она позволяет вам работать над новыми функциями или исправлениями, не затрагивая основную (обычно main или master) ветку.\n4. Слияние (Merge): Слияние — это процесс объединения изменений из одной ветки в другую. Обычно сливаются изменения из ветки функции в основную ветку.\n5. Удалённый репозиторий (Remote Repository): Это версия вашего репозитория, размещённая на сервере. Вы можете взаимодействовать с удалённым репозиторием для совместной работы с другими разработчиками.\n6. Пулл (Pull): Команда, которая позволяет загрузить изменения из удалённого репозитория и объединить их с вашей локальной веткой.\n7. Пуш (Push): Команда, которая отправляет ваши локальные коммиты в удалённый репозиторий.')
        },
        'Менеджер пакетов': {
          'Pub Dev (Центральный репозиторий пакетов для Flutter и Dart)': CategoryDetail([],
              'Pub Dev — это центральный репозиторий для пакетов и библиотек, разработанных на Dart и Flutter. Он предоставляет разработчикам возможность находить, использовать и делиться пакетами с сообществом.\n\nОсновные функции Pub Dev:\n1. Поиск пакетов: Разработчики могут легко искать и находить нужные пакеты с помощью различных фильтров и категорий.\n2. Документация: Каждому пакету предоставляется документация, которая описывает его функции и методы использования.\n3. Статистика: Pub Dev показывает статистику использования пакетов, включая количество загрузок, поддерживаемые версии Dart и Flutter.\n4. Рейтинг и отзывы: Пользователи могут оставлять отзывы и ставить рейтинги, что помогает другим разработчикам принимать обоснованные решения о выборе пакетов.\n5. Версионирование: Pub Dev поддерживает версионирование пакетов, что позволяет разработчикам легко обновлять свои зависимости до последних стабильных версий.'),
          'Пакет, хранящийся в репозитории Git': CategoryDetail([],
              'Пакеты, хранящиеся в репозиториях Git, позволяют разработчикам использовать код, который хранится в системах контроля версий, таких как GitHub, GitLab или Bitbucket. Это особенно полезно для работы с собственными пакетами или пакетами, которые еще не опубликованы на Pub Dev.\n\nОсновные моменты:\n1. Подключение к репозиторию: Чтобы использовать пакет из Git-репозитория, разработчики могут указать URL-адрес репозитория в своем pubspec.yaml.\n2. Управление версиями: Можно указать конкретные ветки, теги или коммиты, что позволяет точно контролировать используемую версию.\n3. Преимущества: Использование пакетов из Git позволяет легко вносить изменения в код, тестировать его и делиться с командой, не дожидаясь публикации на Pub Dev.'),
          'Локальный пакет': CategoryDetail([],
              'Локальные пакеты — это пакеты, которые хранятся на вашем компьютере, а не в удаленных репозиториях. Это удобно для разработки и тестирования пакетов, которые еще не опубликованы или когда необходимо внести изменения в код пакета.\n\nОсновные моменты:\n1. Использование локального пакета: Чтобы подключить локальный пакет, разработчики могут указать путь к директории в своем pubspec.yaml.\n2. Удобство: Локальные пакеты позволяют разработчикам быстро вносить изменения и тестировать их без необходимости постоянного обновления или публикации.\n3. Тестирование: Это идеальный способ тестирования новых функций и исправлений ошибок перед их отправкой в удаленный репозиторий или публикацией на Pub Dev.')
        },
        'Принцип проектирования': {
          'ООП': CategoryDetail([
            'Classes and Objects (классы и объекты)',
            'Constructors (конструкторы)',
            'Instance Variables (переменные экземпляра)',
            'Methods (методы)',
            'Inheritance (наследование)',
            'Polymorphism (полиморфизм)',
            'Encapsulation (инкапсуляция)',
            'Abstraction (абстракция)',
            'Interfaces (интерфейсы)',
            'Mixins (миксины)',
            'Static Members (статические члены)',
            'Getters and Setters (геттеры и сеттеры)',
          ], 'Объектно-ориентированное программирование (OOP) — это парадигма программирования, основанная на концепциях "объектов", которые могут содержать данные и код: данные в виде полей (атрибутов или свойств), а код в виде процедур (методов). OOP помогает структурировать программы более интуитивно, позволяя моделировать реальные объекты и взаимодействия.\nОписание:\nКласс — это шаблон для создания объектов, который определяет свойства (данные) и методы (функции), которые будут доступны каждому объекту. Объект — это экземпляр класса, который имеет свое состояние и поведение. Например, класс Car может содержать свойства, такие как color и model, и методы, такие как drive() и stop().\n\n2. Constructors (Конструкторы)\nОписание:\nКонструкторы — это специальные методы, которые вызываются при создании объекта. Они инициализируют свойства объекта и могут принимать параметры для задания начальных значений. Например, в классе Person конструктор может принимать имя и возраст как параметры.\n\n3. Instance Variables (Переменные экземпляра)\nОписание:\nПеременные экземпляра — это поля класса, которые хранят состояние каждого объекта. Каждое значение переменной экземпляра уникально для каждого объекта. Например, у двух объектов класса Dog могут быть разные имена и породы, хранящиеся в переменных экземпляра name и breed.\n\n4. Methods (Методы)\nОписание:\nМетоды — это функции, определенные внутри класса, которые описывают поведение объектов. Методы могут изменять состояние объекта, выполнять действия или возвращать значения. Например, метод bark() в классе Dog может выводить звук лая.\n\n5. Inheritance (Наследование)\nОписание:\nНаследование позволяет создавать новый класс на основе существующего. Производный класс наследует свойства и методы родительского класса, что позволяет повторно использовать код. Например, класс Animal может быть родительским классом для классов Dog и Cat.\n\n6. Polymorphism (Полиморфизм)\nОписание:\nПолиморфизм позволяет объектам разных классов использовать один и тот же интерфейс для выполнения действий. Это достигается через переопределение методов. Например, метод makeSound() может быть определен в классах Dog и Cat, но каждый класс будет реализовывать его по-своему.\n\n7. Encapsulation (Инкапсуляция)\nОписание:\nИнкапсуляция — это механизм, позволяющий скрыть внутреннее состояние объекта от внешнего мира и управлять доступом к нему через методы. Это помогает защитить данные и предотвращает их некорректное изменение. Например, поля класса могут быть приватными, а доступ к ним осуществляется через публичные методы.\n\n8. Abstraction (Абстракция)\nОписание:\nАбстракция позволяет выделить общие характеристики объектов и скрыть детали реализации. Это упрощает работу с объектами и помогает сосредоточиться на основном функционале. Например, интерфейсы и абстрактные классы помогают разработать четкие контракты для классов, не задумываясь о реализации.\n\n9. Interfaces (Интерфейсы)\nОписание:\nИнтерфейсы определяют набор методов, которые классы должны реализовать, но не содержат реализаций. Это позволяет создавать обобщенные структуры и использовать полиморфизм. Например, интерфейс Flyable может быть реализован классами Bird и Airplane, каждый из которых имеет свою реализацию метода fly().\n\n10. Mixins (Миксины)\nОписание:\nМиксины — это специальные классы, которые могут быть использованы для добавления функциональности к другим классам без необходимости наследования. Это позволяет повторно использовать код и добавлять новые возможности. Например, миксин Logger может добавлять метод для логирования сообщений в любой класс, который его использует.\n\n11. Static Members (Статические члены)\nОписание:\nСтатические члены класса (переменные и методы) принадлежат классу, а не его экземплярам. Они могут быть вызваны без создания объекта класса. Например, статическая переменная count может отслеживать количество созданных объектов данного класса.\n\n12. Getters and Setters (Геттеры и сеттеры)\nОписание:\nГеттеры и сеттеры — это специальные методы, используемые для доступа и изменения приватных переменных экземпляра. Геттеры возвращают значение переменной, а сеттеры устанавливают его. Это позволяет контролировать доступ к данным и выполнять дополнительные действия при изменении значений. Например, сеттер может проверять корректность входных данных перед установкой значения.'),
          'Принципы SOLID': CategoryDetail([
            'Single Responsibility Principle (SRP) (Принцип единственной ответственности)',
            'Open/Closed Principle (OCP) (Принцип открытости/закрытости)',
            'Liskov Substitution Principle (LSP) (Принцип подстановки Барбары Лисков)',
            'Interface Segregation Principle (ISP) (Принцип разделения интерфейса)',
            'Dependency Inversion Principle (DIP) (Принцип инверсии зависимостей)',
          ], '1. Single Responsibility Principle (SRP) (Принцип единственной ответственности)\nОписание:\nКаждый класс должен иметь только одну причину для изменения, то есть должен иметь только одну ответственность. Это означает, что класс должен выполнять только одну задачу или функциональность. Например, класс ReportGenerator отвечает только за генерацию отчетов, в то время как класс ReportPrinter отвечает только за печать отчетов. Это упрощает сопровождение и тестирование кода.\n\n2. Open/Closed Principle (OCP) (Принцип открытости/закрытости)\nОписание:\nКлассы должны быть открыты для расширения, но закрыты для модификации. Это означает, что вы должны иметь возможность добавлять новые функциональные возможности к существующему коду без изменения его. Например, вместо изменения класса Shape для добавления новых фигур, вы можете создать новый класс Circle, который наследует от Shape и реализует его методы.\n\n3. Liskov Substitution Principle (LSP) (Принцип подстановки Лисков)\nОписание:\nОбъекты базового класса должны быть заменяемы объектами производных классов без изменения правильности программы. Это подразумевает, что производные классы должны поддерживать контракт базового класса. Например, если класс Bird имеет метод fly(), производный класс Penguin, который не может летать, не должен наследовать этот метод. Вместо этого следует создать другой интерфейс или базовый класс, чтобы избежать нарушений принципа.\n\n4. Interface Segregation Principle (ISP) (Принцип разделения интерфейсов)\nОписание:\nКлиенты не должны зависеть от интерфейсов, которые они не используют. Вместо одного общего интерфейса следует создавать несколько специализированных интерфейсов. Это позволяет уменьшить зависимость классов и облегчает их тестирование. Например, вместо одного интерфейса Animal с методами walk(), fly() и swim(), лучше создать интерфейсы Walker, Flyer и Swimmer, чтобы разные классы могли реализовывать только нужные методы.\n\n5. Dependency Inversion Principle (DIP) (Принцип инверсии зависимостей)\nОписание:\nМодули высшего уровня не должны зависеть от модулей низшего уровня; обе группы должны зависеть от абстракций. Кроме того, абстракции не должны зависеть от деталей; детали должны зависеть от абстракций. Это означает, что следует использовать интерфейсы или абстрактные классы для определения зависимостей, чтобы минимизировать связность. Например, вместо создания экземпляра класса Database внутри класса UserService, лучше передавать интерфейс IDatabase в конструктор UserService, чтобы обеспечить гибкость и возможность тестирования.'),
          'Шаблон проектирования': CategoryDetail([
            'Singleton (Одиночное использование)',
            'Factory (фабричный конструктор)',
            'Builder (Строитель)',
            'Adapter (Адаптер)',
            'Observer (Наблюдатель)',
            'Repository (Репозиторий)',
            'Model-View-ViewModel (MVVM) (Модель-Представление)',
            'Provider (State Management)',
            'Bloc (Business Logic Component)',
            'Decorator (Декоратор)',
            'Command (Команда)',
            'Dependency Injection (DI) (Внедрение зависимосетей)',
            'Facade (Фасад)',
            'Strategy (Стратегия)',
          ], '1. Singleton (Одиночное использование)\nОписание:\nШаблон, который гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру. Он полезен, когда необходимо управлять общим состоянием или ресурсами, например, настройками приложения или подключениями к базе данных.\n\n2. Factory Method (Фабричный метод)\nОписание:\nШаблон, который предоставляет интерфейс для создания объектов, не указывая их конкретный класс. Это позволяет делегировать создание объектов подклассам, что упрощает код и его поддержку.\n\n3. Builder (Строитель)\nОписание:\nШаблон, который разделяет процесс создания сложного объекта на несколько этапов. Он позволяет пошагово настраивать объект и скрывает детали реализации. Это удобно для создания объектов с множеством опциональных параметров.\n\n4. Adapter (Адаптер)\nОписание:\nШаблон, который позволяет объектам с несовместимыми интерфейсами работать вместе. Адаптер оборачивает интерфейс одного класса, чтобы соответствовать интерфейсу другого, что обеспечивает взаимодействие между различными системами.\n\n5. Observer (Наблюдатель)\nОписание:\nШаблон, который определяет зависимость \"один ко многим\" между объектами, так что при изменении состояния одного объекта все его зависимые объекты уведомляются и обновляются автоматически. Это полезно для реализации паттерна \"издатель-подписчик\".\n\n6. Repository (Репозиторий)\nОписание:\nШаблон, который обеспечивает абстракцию доступа к данным, позволяя отделить бизнес-логику от логики доступа к данным. Репозиторий предоставляет интерфейс для выполнения операций CRUD (создание, чтение, обновление, удаление) и управления жизненным циклом объектов.\n\n7. Model-View-ViewModel (MVVM) (Модель-Представление)\nОписание:\nШаблон проектирования, который разделяет логику пользовательского интерфейса на три компонента: Модель (данные), Представление (UI) и Модель представления (логика обработки). Это упрощает тестирование и управление состоянием приложения.\n\n8. Provider (State Management) (Управление состоянием)\nОписание:\nШаблон, который используется для управления состоянием в приложении. Он позволяет разделять логику состояния и представление, что делает код более чистым и простым в сопровождении. Обычно используется с помощью ChangeNotifier.\n\n9. Bloc (Business Logic Component) (Бизнес-логика компонента)\nОписание:\nШаблон, который помогает организовать бизнес-логику в приложении, используя потоки (Streams) и события. Это позволяет отделить логику от пользовательского интерфейса и упростить тестирование.\n\n10. Decorator (Декоратор)\nОписание:\nШаблон, который позволяет динамически добавлять новые функциональные возможности к объектам, не изменяя их структуру. Декораторы обеспечивают гибкость в расширении функциональности, позволяя комбинировать различные объекты.\n\n11. Command (Команда)\nОписание:\nШаблон, который превращает запросы в объекты, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь и логировать их. Он также поддерживает отмену операций.\n\n12. Dependency Injection (DI) (Внедрение зависимостей)\nОписание:\nШаблон, который позволяет передавать зависимости объектам, вместо их создания внутри объекта. Это улучшает тестируемость и уменьшает связанность между компонентами приложения.\n\n13. Facade (Фасад)\nОписание:\nШаблон, который предоставляет унифицированный интерфейс к набору интерфейсов в подсистеме. Фасад упрощает использование сложных систем, скрывая детали реализации и предоставляя более простой интерфейс.\n\n14. Strategy (Стратегия)\nОписание:\nШаблон, который позволяет определять семейство алгоритмов, инкапсулировать каждый из них и делать их взаимозаменяемыми. Это позволяет изменять алгоритмы независимо от клиентов, которые их используют.')
        },
        'Хранилище': {
          'Shared Preferences': CategoryDetail([],
              'Shared Preferences — это простой способ хранения небольших объемов данных, таких как настройки или пользовательские предпочтения, в виде пар "ключ-значение". Это удобно для хранения простых данных, таких как логины, настройки интерфейса и другие параметры.'),
          'SQLite': CategoryDetail([],
              'Локальные базы данных, такие как SQLite, используются для хранения структурированных данных в виде таблиц. Flutter поддерживает работу с SQLite через такие пакеты, как sqflite и moor. Это позволяет создавать, читать, обновлять и удалять данные на устройстве.'),
          'Firebase': CategoryDetail([],
              'Для хранения данных на удаленных серверах можно использовать облачные решения, такие как Firebase Cloud Storage. Это позволяет загружать и загружать файлы из облака, а также работать с большими объемами данных, не занимая место на устройстве пользователя.')
        },
        'Программный интерфейс приложения': {
          'REST': CategoryDetail([],
              'REST (Representational State Transfer) — это архитектурный стиль, основанный на HTTP, который используется для разработки веб-сервисов. RESTful API использует стандартные HTTP методы (GET, POST, PUT, DELETE) для выполнения операций над ресурсами. В Flutter взаимодействие с RESTful API часто осуществляется с помощью пакета http или Dio.'),
          'GraphQL': CategoryDetail([],
              'GraphQL — это язык запросов для API, который предоставляет клиентам возможность запрашивать только те данные, которые им нужны. В отличие от REST, где каждое обращение к API возвращает фиксированный набор данных, в GraphQL вы можете гибко задавать структуру ответа. Для работы с GraphQL в Flutter можно использовать пакеты, такие как graphql_flutter.'),
          'Web Sockets': CategoryDetail([],
              'WebSockets — это протокол для двусторонней связи между клиентом и сервером через единственное соединение. Он позволяет обмениваться данными в режиме реального времени, что делает его идеальным для приложений, которые требуют мгновенной передачи данных, таких как чаты, игры, или финансовые приложения.')
        },
        'Продвинутый Dart': {
          'Основной пакет': CategoryDetail([],
              'Core Package (Основной пакет)\nОсновной пакет Dart содержит базовые библиотеки, которые предоставляют функциональность, необходимую для разработки приложений. Это включает в себя работу с числами, строками, коллекциями и асинхронным программированием. Библиотеки, такие как dart:core, являются частью каждого Dart-приложения и предоставляют основные классы и функции, которые используются во всех приложениях.\n\nОсновные компоненты:\nString: для работы со строками.\nNum: для работы с числовыми значениями.\nList, Set, Map: для работы с коллекциями данных.'),
          'Коллекции': CategoryDetail([],
              'Collections (Коллекции)\nКоллекции в Dart представляют собой структуры данных, которые позволяют хранить и обрабатывать группы объектов. Dart предоставляет несколько типов коллекций, включая списки (List), множества (Set) и ассоциативные массивы (Map). Каждая из этих коллекций имеет свои особенности и методы.\n\nПримеры:\nList: упорядоченная коллекция, которая может содержать дубликаты.\nSet: неупорядоченная коллекция уникальных элементов.\nMap: коллекция пар \"ключ-значение\".'),
          'Лямбды': CategoryDetail([],
              'Lambdas (Лямбды)\nЛямбда-функции, или анонимные функции, позволяют создавать функции без имени, которые могут быть переданы как аргументы или присвоены переменным. Это полезно для упрощения кода и уменьшения его избыточности, особенно в функциональном программировании.'),
          'Асинхронность/ожидание': CategoryDetail([],
              'Async/Await (Асинхронность/Ожидание)\nAsync/Await в Dart упрощает работу с асинхронным кодом. Использование ключевого слова async перед функцией позволяет вам использовать await для асинхронных операций, что делает код более читаемым и похожим на синхронный.'),
          'Изоляты': CategoryDetail([],
              'Isolate (Изоляты)\nИзоляты в Dart предоставляют возможность параллельного выполнения кода. Каждая изоляция имеет собственную память и не может напрямую взаимодействовать с другими изоляциями, что обеспечивает безопасность при многопоточном выполнении. Это позволяет избежать проблем, связанных с синхронизацией.')
        },
        'Управление состоянием': {
          'Provider': CategoryDetail([],
              'Provider — это библиотека для управления состоянием, основанная на InheritedWidget, но упрощающая процесс. Она позволяет легко делиться состоянием между виджетами и автоматически управляет подписками на изменения состояния.'),
          'Bloc': CategoryDetail([],
              'Bloc (Business Logic Component) — это архитектурный паттерн, который разделяет бизнес-логику и интерфейс пользователя. Он использует потоки (Streams) для передачи состояния и событий, что позволяет управлять сложным состоянием приложения более предсказуемо.'),
          'Redux': CategoryDetail([],
              'Redux — это библиотека для управления состоянием, вдохновленная одноименной библиотекой JavaScript. Она предлагает централизованное хранилище (store), которое управляет состоянием приложения, используя строгий однонаправленный поток данных. Redux разделяет приложение на три основные части: состояния, действия и редьюсеры, что способствует предсказуемости и тестируемости.'),
          'GetX': CategoryDetail([],
              'GetX — это библиотека, предоставляющая удобные и мощные инструменты для управления состоянием, маршрутизацией и зависимостями. Она предлагает простой и интуитивно понятный API, поддерживает реактивное программирование и фокусируется на высокой производительности. GetX позволяет разработчикам легко управлять состоянием с минимальным количеством кода и высокой эффективностью.'),
          'Riverpod': CategoryDetail([],
              'Riverpod — это современный подход к управлению состоянием, который улучшает и упрощает использование Provider. Он предлагает более чистый способ управления состоянием и является более безопасным и эффективным.')
        },
        'Аутентификация': {
          'Firebase': CategoryDetail([],
              'Аутентификация — это процесс проверки подлинности пользователя или системы. В контексте мобильных приложений аутентификация позволяет пользователям входить в приложение, используя свои учетные данные, такие как имя пользователя и пароль, или другие методы, такие как социальные сети, биометрия (отпечаток пальца, распознавание лица) и одноразовые пароли (OTP).'),
          'Custom': CategoryDetail([],
              'Аутентификация — это процесс проверки подлинности пользователя или системы. В контексте мобильных приложений аутентификация позволяет пользователям входить в приложение, используя свои учетные данные, такие как имя пользователя и пароль, или другие методы, такие как социальные сети, биометрия (отпечаток пальца, распознавание лица) и одноразовые пароли (OTP).'),
        },
        'Push-уведомление': {
          'Firebase': CategoryDetail([],
              'Пуш-уведомления — это сообщения, которые отправляются на устройство пользователя из сервера приложения, даже когда приложение не активно или закрыто. Они позволяют разработчикам взаимодействовать с пользователями, информировать их о новых событиях, акциях, обновлениях или другой важной информации.\n\nОсновные особенности пуш-уведомлений:\n1. Сигналы о новых событиях:\n\t\t*Пуш-уведомления могут использоваться для информирования пользователей о новых сообщениях, событиях или обновлениях, что помогает поддерживать их вовлеченность.\n\n2. Персонализация:\n\t\t*Уведомления могут быть персонализированы на основе интересов и поведения пользователя, что увеличивает вероятность их открытия.\n\n3. Повышение вовлеченности:\n\t\t*С помощью пуш-уведомлений можно напомнить пользователям о вашем приложении и увеличить его использование.\n\nИнтерактивные уведомления:\n\t\t*Некоторые уведомления могут содержать действия (например, кнопки), которые позволяют пользователю выполнять действия непосредственно из уведомления.\n\nFirebase Cloud Messaging (FCM) один из самых популярных способов реализации пуш-уведомлений в приложениях Flutter.\nПозволяет отправлять уведомления пользователям на Android и iOS.'),
          'Custom': CategoryDetail([],
              'Пуш-уведомления — это сообщения, которые отправляются на устройство пользователя из сервера приложения, даже когда приложение не активно или закрыто. Они позволяют разработчикам взаимодействовать с пользователями, информировать их о новых событиях, акциях, обновлениях или другой важной информации.\n\nОсновные особенности пуш-уведомлений:\n1. Сигналы о новых событиях:\n\t\t*Пуш-уведомления могут использоваться для информирования пользователей о новых сообщениях, событиях или обновлениях, что помогает поддерживать их вовлеченность.\n\n2. Персонализация:\n\t\t*Уведомления могут быть персонализированы на основе интересов и поведения пользователя, что увеличивает вероятность их открытия.\n\n3. Повышение вовлеченности:\n\t\t*С помощью пуш-уведомлений можно напомнить пользователям о вашем приложении и увеличить его использование.\n\nИнтерактивные уведомления:\n\t\t*Некоторые уведомления могут содержать действия (например, кнопки), которые позволяют пользователю выполнять действия непосредственно из уведомления.\n\nFirebase Cloud Messaging (FCM) один из самых популярных способов реализации пуш-уведомлений в приложениях Flutter.\nПозволяет отправлять уведомления пользователям на Android и iOS.'),
        },
        'Тестирование': {
          'Юнит тестирование': CategoryDetail([],
              'Testing (Тестирование)\nОписание:\nТестирование — это процесс оценки функциональности приложения для обеспечения его корректности и надежности. В разработке на Flutter тестирование может включать в себя несколько уровней, включая юнит-тестирование, тестирование виджетов и интеграционное тестирование. Это позволяет разработчикам выявлять ошибки и проблемы на ранних стадиях, улучшая качество конечного продукта.\n\nОсновные типы тестирования в Flutter:\n1. Юнит-тестирование (Unit Testing):\n\n\t\t*Проверяет отдельные функции или методы на уровне кода.\n\t\t*Позволяет удостовериться, что каждая часть кода работает правильно изолированно от других.\n\t\t*Используется для тестирования бизнес-логики.\n\n2. Тестирование виджетов (Widget Testing):\n\n\t\t*Позволяет проверять пользовательский интерфейс (UI) и поведение виджетов.\n\t\t*Тесты выполняются в изолированной среде, позволяя имитировать пользовательские взаимодействия.\n\n3. Интеграционное тестирование (Integration Testing):\n\n\t\t*Проверяет взаимодействие между несколькими модулями и целыми приложениями.\n\t\t*Используется для оценки всей функциональности приложения в условиях, приближенных к реальным.'),
          'Виджет-тест': CategoryDetail([],
              'Testing (Тестирование)\nОписание:\nТестирование — это процесс оценки функциональности приложения для обеспечения его корректности и надежности. В разработке на Flutter тестирование может включать в себя несколько уровней, включая юнит-тестирование, тестирование виджетов и интеграционное тестирование. Это позволяет разработчикам выявлять ошибки и проблемы на ранних стадиях, улучшая качество конечного продукта.\n\nОсновные типы тестирования в Flutter:\n1. Юнит-тестирование (Unit Testing):\n\n\t\t*Проверяет отдельные функции или методы на уровне кода.\n\t\t*Позволяет удостовериться, что каждая часть кода работает правильно изолированно от других.\n\t\t*Используется для тестирования бизнес-логики.\n\n2. Тестирование виджетов (Widget Testing):\n\n\t\t*Позволяет проверять пользовательский интерфейс (UI) и поведение виджетов.\n\t\t*Тесты выполняются в изолированной среде, позволяя имитировать пользовательские взаимодействия.\n\n3. Интеграционное тестирование (Integration Testing):\n\n\t\t*Проверяет взаимодействие между несколькими модулями и целыми приложениями.\n\t\t*Используется для оценки всей функциональности приложения в условиях, приближенных к реальным.'),
          'Интеграционное тестирование': CategoryDetail([],
              'Testing (Тестирование)\nОписание:\nТестирование — это процесс оценки функциональности приложения для обеспечения его корректности и надежности. В разработке на Flutter тестирование может включать в себя несколько уровней, включая юнит-тестирование, тестирование виджетов и интеграционное тестирование. Это позволяет разработчикам выявлять ошибки и проблемы на ранних стадиях, улучшая качество конечного продукта.\n\nОсновные типы тестирования в Flutter:\n1. Юнит-тестирование (Unit Testing):\n\n\t\t*Проверяет отдельные функции или методы на уровне кода.\n\t\t*Позволяет удостовериться, что каждая часть кода работает правильно изолированно от других.\n\t\t*Используется для тестирования бизнес-логики.\n\n2. Тестирование виджетов (Widget Testing):\n\n\t\t*Позволяет проверять пользовательский интерфейс (UI) и поведение виджетов.\n\t\t*Тесты выполняются в изолированной среде, позволяя имитировать пользовательские взаимодействия.\n\n3. Интеграционное тестирование (Integration Testing):\n\n\t\t*Проверяет взаимодействие между несколькими модулями и целыми приложениями.\n\t\t*Используется для оценки всей функциональности приложения в условиях, приближенных к реальным.'),
        },
        'Инструменты разработчика': {
          'Инструмент отладки': CategoryDetail([],
              'Flutter Inspector — это инструмент, позволяющий разработчикам визуализировать и исследовать структуру виджетов в приложении. Он помогает анализировать и отлаживать интерфейс, показывая иерархию виджетов, их свойства и состояние.\nФункции:\n\t\t*Выбор виджетов: Позволяет выделять виджеты прямо на экране приложения для быстрого анализа их свойств и стилей.\n\t\t*Изменение свойств в реальном времени: Вы можете вносить изменения в свойства виджетов и сразу видеть результат на экране, что упрощает настройку интерфейса.\n\t\t*Проверка построения виджетов: Указывает на проблемы с построением виджетов, такие как переполнение или ошибки компоновки.'),
          'Структурный обзор': CategoryDetail([],
              'Flutter Outline предоставляет структурный обзор иерархии виджетов в приложении. Он показывает, как различные виджеты взаимосвязаны, и позволяет легко находить иерархические уровни.\nФункции:\n\t\t*Обзор структуры: Отображает полное дерево виджетов с их свойствами и состоянием, что упрощает понимание структуры интерфейса.\n\t\t*Поиск виджетов: Позволяет быстро находить и выбирать виджеты, что делает отладку и изменение интерфейса более эффективным.\n\t\t*Навигация: Упрощает навигацию по коду, показывая соответствие между иерархией виджетов и исходным кодом.'),
          'Распределение памяти': CategoryDetail([],
              'Инструмент распределения памяти позволяет разработчикам отслеживать использование памяти их приложениями, что помогает выявлять утечки памяти и оптимизировать ресурсы.\nФункции:\n\t\t*Отслеживание использования памяти: Позволяет видеть, сколько памяти использует приложение, и анализировать, как она распределяется между различными объектами и виджетами.\n\t\t*Профилирование: Помогает выявить узкие места в использовании памяти, позволяя разработчикам оптимизировать код для снижения потребления ресурсов.\n\t\t*Анализ объектов: Предоставляет возможность видеть, какие объекты занимают память и когда они освобождаются, что способствует улучшению общей производительности приложения.'),
        },
        'Интернационализация': {
          'Localization Package': CategoryDetail([
            'inltl',
            'Easy_localization',
          ], 'Localization Package (Пакет локализации)\n\nПакет локализации в Flutter предоставляет разработчикам инструменты для поддержки многозначных языков и культур, позволяя приложениям быть доступными и понятными для пользователей из разных регионов. Он помогает управлять текстами, переводами и другими локализованными ресурсами.\n\nОсновные функции\n\n\t\t*Переводы: Пакет позволяет разработчикам легко управлять переводами текстов для различных языков, что позволяет пользователям выбирать предпочитаемый язык интерфейса.\n\t\t*Управление ресурсами: Локализация пакета включает в себя возможность работы с изображениями, аудиофайлами и другими ресурсами, которые могут различаться в зависимости от языка.\n\t\t*Форматирование: Пакет поддерживает автоматическое форматирование дат, чисел и валют в соответствии с локальными стандартами, улучшая взаимодействие пользователя с приложением.\n\t\t*Легкость интеграции: Пакет легко интегрируется в существующие приложения и предоставляет понятный API для работы с локализацией.\n\nИспользуемые пакеты\n\t\t*easy_localization — это мощный пакет, который упрощает процесс локализации приложений на Flutter. Он предлагает удобный API для работы с переводами и поддерживает как JSON, так и ARB файлы.\n\t\t*intl: Пакет intl используется для форматирования дат, чисел и строк с учетом локальных стандартов, что делает его незаменимым для интернационализации.'),
          'Transition': CategoryDetail(
            ['Google Sheet (Google таблицы)', 'Localizely', 'POEditor'],
            'Google Sheets (Google таблицы)\n\nGoogle Sheets — это облачный сервис для работы с таблицами, который позволяет командам эффективно сотрудничать в процессе локализации. Локализаторы могут легко вносить изменения, добавлять переводы и отслеживать версионность.\n\nОсновные функции:\n\t\t*Совместная работа в реальном времени с другими участниками проекта.\n\t\t*Поддержка формул и функций для автоматизации задач локализации.\n\t\t*Легкий экспорт данных в различных форматах для интеграции с приложением.\n\nПрименение в приложении: Google Sheets может быть использован для хранения текстов локализации, где разработчики могут добавлять строки для перевода, а локализаторы смогут легко редактировать их.\n\nLocalizely\n\nLocalizely — это платформа, ориентированная на локализацию приложений и веб-сайтов, предлагающая инструменты для управления переводами и интеграции с существующими проектами.\n\nОсновные функции:\n\t\t*Интуитивно понятный интерфейс для управления проектами локализации.\n\t\t*Поддержка автоматических переводов и инструменты для их редактирования.\n\t\t*Интеграция с популярными фреймворками и библиотеками для упрощения рабочего процесса.\nПрименение в приложении: Localizely позволяет командам локализации эффективно управлять переводами и поддерживать актуальность текстов в приложении.\n\nPOEditor \n\nPOEditor — это онлайн-платформа для управления переводами, которая позволяет командам сотрудничать в процессе локализации, предоставляя инструменты для импорта и экспорта строк, а также для работы с переводами.\nОсновные функции:\n\t\t*Легкий импорт и экспорт текстов локализации в различных форматах, включая CSV и XLIFF.\n\t\t*Инструменты для автоматизации переводов, такие как Machine Translation (машинный перевод).\n\t\t*Удобный интерфейс для отслеживания прогресса переводов и управления задачами.\n\nПрименение в приложении: POEditor может использоваться для централизованного управления переводами, обеспечивая быструю и эффективную локализацию приложений на различных языках.',
          )
        },
        'Аналитика': {
          'Google аналитика': CategoryDetail([],
              'Инструменты аналитики в мобильных приложениях позволяют собирать, анализировать и интерпретировать данные о поведении пользователей, производительности, взаимодействиях и других метриках. Эти данные помогают принимать обоснованные решения, улучшать интерфейсы, повышать конверсию и оптимизировать пользовательский опыт.\n\nОсновные инструменты и метрики для аналитики:\n\nFirebase Analytics\n\nБесплатный инструмент от Google, оптимизированный для мобильных приложений. Firebase Analytics предоставляет данные о взаимодействии пользователей, сеансах, демографических показателях и многом другом.\nОсновные функции:\n\t\t*Отслеживание событий (например, нажатий, переходов между экранами).\n\t\t*Поддержка расширенной аналитики для углубленного анализа поведения.\n\t\t*Интеграция с другими инструментами Firebase для A/B-тестирования, мониторинга производительности и уведомлений.\n\nFirebase Analytics позволяет отслеживать ключевые показатели (KPIs), такие как удержание пользователей, конверсии, активные пользователи, а также выявлять слабые места в интерфейсе.\n\nGoogle Analytics for Mobile\n\nПопулярный аналитический инструмент для отслеживания поведения пользователей в приложениях и веб-сайтах. Google Analytics дает широкий обзор аудитории, источников трафика и данных об активностях.\n\nОсновные функции:\n\t\t*Сегментация аудитории и отслеживание воронок конверсий.\n\t\t*Возможность построения индивидуальных отчетов.\n\t\t*Отчеты в реальном времени.\n\nGoogle Analytics используется для комплексного анализа пользовательских данных и построения прогнозов, что помогает улучшить целевые страницы и удержание пользователей.'),
          'Аналитика Firebase': CategoryDetail([],
              'Инструменты аналитики в мобильных приложениях позволяют собирать, анализировать и интерпретировать данные о поведении пользователей, производительности, взаимодействиях и других метриках. Эти данные помогают принимать обоснованные решения, улучшать интерфейсы, повышать конверсию и оптимизировать пользовательский опыт.\n\nОсновные инструменты и метрики для аналитики:\n\nFirebase Analytics\n\nБесплатный инструмент от Google, оптимизированный для мобильных приложений. Firebase Analytics предоставляет данные о взаимодействии пользователей, сеансах, демографических показателях и многом другом.\nОсновные функции:\n\t\t*Отслеживание событий (например, нажатий, переходов между экранами).\n\t\t*Поддержка расширенной аналитики для углубленного анализа поведения.\n\t\t*Интеграция с другими инструментами Firebase для A/B-тестирования, мониторинга производительности и уведомлений.\n\nFirebase Analytics позволяет отслеживать ключевые показатели (KPIs), такие как удержание пользователей, конверсии, активные пользователи, а также выявлять слабые места в интерфейсе.\n\nGoogle Analytics for Mobile\n\nПопулярный аналитический инструмент для отслеживания поведения пользователей в приложениях и веб-сайтах. Google Analytics дает широкий обзор аудитории, источников трафика и данных об активностях.\n\nОсновные функции:\n\t\t*Сегментация аудитории и отслеживание воронок конверсий.\n\t\t*Возможность построения индивидуальных отчетов.\n\t\t*Отчеты в реальном времени.\n\nGoogle Analytics используется для комплексного анализа пользовательских данных и построения прогнозов, что помогает улучшить целевые страницы и удержание пользователей.'),
        },
        'Развертывание': {
          'Play Store': CategoryDetail([],
              'Play Store\nПлатформа для распространения приложений на Android. Google Play Store позволяет разработчикам публиковать приложения, которые затем становятся доступны для загрузки пользователям Android-устройств по всему миру. В Play Store также есть система для анализа отзывов, предоставления обновлений и отслеживания метрик. Требует подписки на аккаунт Google Play Console и соблюдения политики Google для приложений.'),
          'App Store': CategoryDetail([],
              'App Store\nМагазин приложений от Apple, предназначенный для устройств на iOS. App Store требует, чтобы разработчики соответствовали строгим требованиям безопасности и качества, а также подписали приложение цифровым сертификатом. Процесс публикации проходит через App Store Connect, и рассмотрение приложения может занять несколько дней. Включает инструменты для управления обновлениями, отзывами и аналитикой'),
          'Другие': CategoryDetail([],
              'Other\nСуществуют и альтернативные площадки для распространения мобильных приложений, такие как Amazon Appstore, Samsung Galaxy Store или Huawei AppGallery. Эти магазины также предлагают платформы для публикации и распространения приложений, но требования и процесс публикации могут отличаться от Google Play и App Store.'),
        }
      }),
  /*FlutterEntity(
      image: 'assets/images/FlutterImage.svg',
      title: 'Development with Flutter',
      description: 'Create cross-platform applications that are high-performing and have a flexible design.',
      entries: {
        'Developer Environment (Среда разработки)': {
          'IDE (интегрированная среда разработки)': CategoryDetail([
            'Android Studio',
            'VS Code'
          ],
              "IDE (Integrated Development Environment) — это программная среда, объединяющая множество инструментов для упрощения разработки и повышения продуктивности разработчиков. В контексте разработки на Flutter, IDE помогает быстро создавать, тестировать и отлаживать мобильные и веб-приложения, предлагая интеграцию с необходимыми библиотеками и пакетами.\n\nОсновные возможности IDE для Flutter:\n\nАвтозаполнение и подсказки\nПомогает разработчику быстрее писать код, предлагая варианты автодополнения и контекстные подсказки для Flutter и Dart.\n\nОтладка (Debugging)\nИнструменты для пошагового выполнения кода, просмотра значений переменных, и отслеживания ошибок в режиме реального времени.\n\nПостроение интерфейсов\nIDE, такие как Android Studio и VS Code, поддерживают функции предварительного просмотра, позволяя видеть, как будет выглядеть интерфейс на реальном устройстве.\n\nУправление проектом и сборками\nВключает управление зависимостями, сборку проекта, управление версиями и инструменты для развертывания.\n\nИнтеграция с эмуляторами и устройствами\nПозволяет запускать приложения на эмуляторах Android и iOS, а также на подключенных реальных устройствах для тестирования.\n\nПопулярные IDE для Flutter:\n\nAndroid Studio: IDE от Google с полноценной поддержкой Flutter и мощным набором инструментов.\nVisual Studio Code (VS Code): Легкая и расширяемая IDE, поддерживающая Flutter через плагины."),
          'Flutter SDK (набор инструментов Flutter)': CategoryDetail([
            'Flutter CLI (командная строка Flutter)'
          ],
              'Flutter SDK — это комплект инструментов для разработки приложений на Flutter, созданный Google. SDK (Software Development Kit) предоставляет все необходимое для написания, тестирования и сборки кроссплатформенных приложений, работающих на Android, iOS, веб и настольных платформах.\n\nОсновные компоненты Flutter SDK:\n\nФреймворк Flutter\nСодержит набор виджетов (widgets), компонентов для построения интерфейсов, а также утилиты и библиотеки, которые позволяют создавать приложения с единой кодовой базой для разных платформ.\n\nКомпилятор Dart\nFlutter использует язык программирования Dart, и компилятор в составе SDK позволяет преобразовывать код Dart в нативный машинный код для повышения производительности приложений.\n\nИнструменты командной строки\nНабор команд (например, flutter run, flutter build, flutter doctor) для управления проектом, его сборки и развертывания. Команды позволяют также диагностировать проблемы с зависимостями и настройками среды разработки.\n\nHot Reload и Hot Restart\nЭти функции позволяют разработчику вносить изменения в код и сразу видеть результат в реальном времени, без необходимости полной перезагрузки приложения. Hot Reload обновляет состояние экрана без перезапуска, а Hot Restart — выполняет полную перезагрузку приложения, начиная с главного экрана.\n\nDevTools\nНабор инструментов для отладки и мониторинга производительности приложения, включая просмотр логов, анализ использования памяти и CPU, а также мониторинг рендеринга экрана.\n\nПлагины и пакеты\nSDK поддерживает сторонние библиотеки и плагины, что позволяет интегрировать в приложение такие функции, как доступ к камере, геолокации, сети, базам данных и многому другому.')
        },
        'Dart Basics (Основы Dart)': {
          'Variables (Переменные)': CategoryDetail(
              [
                'int (целое число)',
                'double (число с плавающей запятой)',
                'String (строка)',
                'Bool (логическое значение)',
                'List (Список/Лист)',
                'Map (словарь)',
                'Set (множество уникальных значений)',
                'Var (переменная)',
                'Dynamic (динамический тип)',
                'Const (константа)',
                'Final (неизменяемая переменная)',
                'Runes (руны)',
                'Symbol (символ)',
              ],
              'Переменные и типы данных\nПеременная - это место хранения данных, а типы данных - это тип и размер данных, связанных с переменными и функциями.\nДля объявления переменной в Dart используется ключевое слово var. Синтаксис переменной var приведен ниже,\nvar name = '
                  'Dart'
                  ';\nКлючевое слово final и const используются для объявления констант. Они определяются следующим образом:\n\nvoid main() {\nfinal a = 12;\nconst pi = 3.14;\nprint(a); print(pi);\n}\n\nЯзык Dart поддерживает следующие типы данных:\nЧисла: Используется для представления числовых литералов - Integer и Double.\nСтроки: Представляют собой последовательность символов. Значения строк указываются в одинарных или двойных кавычках.\nБулевы: В Dart используется ключевое слово bool для представления булевых значений - true и false.\nСписки и карты: Используются для представления коллекции объектов. Простой список можно определить следующим образом:\n\nvoid main() {\nvar list = [1,2,3,4,5];\nprint(list);\n}\n\nИз приведенного выше списка получается список [1,2,3,4,5].\nКарта может быть определена, как показано здесь:\n\nvoid main() {\nvar mapping = {'
                  'id'
                  ': 1,'
                  'name'
                  ':'
                  'Dart'
                  '};\nprint(mapping);\n}\n\nДинамический: если тип переменной не определен, то по умолчанию она имеет динамический тип. Следующий пример иллюстрирует переменную динамического типа:\n\nvoid main() {\ndynamic name = "Dart";\nprint(name);\n}'),
          'Functions (Функции)': CategoryDetail(
              [
                'Regular (Регулярный)',
                'Void (пустой тип)',
                'Anonymous Functions (Анонимные функции)',
                'Arrow Functions (Стрелочные функции)',
                'Higher-Order Functions (Функции высшего порядка)',
                'Async Functions (Асинхронные функции)',
                'Generator Functions (Функции-генераторы)',
              ],
              'Функции в Dart — это самостоятельные блоки кода, которые выполняют определенные действия. Они позволяют организовывать код, повторно использовать его и повышать его читаемость. В Dart функции могут принимать аргументы, возвращать значения и даже быть переданы как объекты.\n\nОпределение функции: Функция в Dart определяется с использованием ключевого слова void (если она не возвращает значение) или с указанием типа возвращаемого значения. Синтаксис выглядит следующим образом:\n\nReturnType functionName(ParameterType parameterName) {\n // Тело функции\n}\nПример:\n\nint add(int a, int b) {\n return a + b;\n}\n\nТипы функций:\n\n1. Обычные функции:\nОпределяются с помощью имени и могут быть вызваны в любом месте программы.\nПример:\n\nvoid greet(String name) {\n print('
                  'Hello, \$name!'
                  ');\n}\n\n2. Анонимные функции (лямбды):\nНе имеют имени и могут быть присвоены переменным.\nПример:\n\nvar multiply = (int a, int b) => a * b;\n\n3. Функции высшего порядка:\nМогут принимать функции в качестве аргументов или возвращать их.\nПример:\n\nvoid performOperation(int a, int b, Function operation) {\n print('
                  'Результат: \${operation(a, b)}'
                  ');\n}\n\n4. Функции с именованными параметрами:\nПозволяют передавать аргументы в любом порядке.\nПример:\n\nvoid createAccount({String? username, String? email}) {\n // Логика создания аккаунта\n}\n\n5. Функции с необязательными параметрами:\nОпределяются с использованием квадратных скобок.\nПример:\n\nvoid printInfo(String name, [int? age]) {\n print('
                  'Name: \$name, Age: \${age ?? '
                  'неизвестно'
                  '}'
                  ');\n}\n\n значений: Функции могут возвращать значения, которые можно использовать в других частях программы. Если функция не возвращает значения, используется тип void.\n\nПример с возвратом значения:\n\nString getFullName(String firstName, String lastName) {\n return '
                  '\$firstName \$lastName'
                  ';\n}\n\nСтатические и экземплярные методы: В Dart функции также могут быть определены как методы внутри классов. Методы могут быть статическими (принадлежат классу) или экземплярными (принадлежат экземпляру класса).\n\nПример метода в классе:\n\nclass Calculator {\n int add(int a, int b) {\n return a + b;\n }\n}.'),
          'Operators (Операторы)': CategoryDetail([
            'Arithmetic Operators (Арифметические операторы)',
            'Equality and Relational Operators (Операторы равенства и отношения)',
            'Type Test Operators (Операторы проверки типа)',
            'Assignment Operators (Операторы присваивания)',
            'Logical Operators (Логические операторы)',
            'Bitwise Operators (Побитовые операторы)',
            'Conditional (Ternary) Operator (Условный (тернарный) оператор)',
            'Cascade Operator (Оператор каскадирования)',
            'Null-aware Operators (Операторы, учитывающие null)'
          ],
              'Операторы в Dart — это специальные символы, которые выполняют операции над переменными и значениями. Dart поддерживает различные типы операторов, включая арифметические, логические, битовые, реляционные и оператор присваивания. Использование операторов позволяет создавать более компактный и читаемый код.'),
          'Control flow Statements (Операторы управления)': CategoryDetail([
            'if (Если)',
            'else (Иначе)',
            'else if (Иначе если)',
            'switch (оператор выбора)',
            'case (случай)',
            'default (значение по умолчанию)',
            'for (цикл для итерации)',
            'while (пока)',
            'do-while (выполнять пока)',
            'break (выход из цикла)',
            'continue (продолжить)',
            'return (возврат значения)',
            'try (попытка обработки)',
            'catch (перехват исключения)',
            'finally (блок завершения)',
            'throw (генерация исключения)',
            'rethrow (повторная генерация исключения)',
          ],
              'Управляющие конструкции в Dart позволяют управлять порядком выполнения кода в зависимости от условий или повторяющихся операций. Они помогают реализовать логику принятия решений и обработки ошибок.\n\n1. Условные операторы\nУсловные операторы используются для выполнения определенного кода в зависимости от выполнения условия.\n\n*if и else Условный оператор if выполняет блок кода, если условие истинно. Блок else выполняется, если условие ложно.\n*else if Позволяет проверять несколько условий.\n*switch Оператор switch используется для выбора одного из множества вариантов в зависимости от значения переменной.\n*case (случай) Обозначает вариант внутри switch, который будет выполнен, если переменная равна заданному значению.\n*default (значение по умолчанию) Блок кода, который выполняется, если ни одно из условий в switch не совпадает.\n\n2. Циклы\nЦиклы используются для повторения блока кода несколько раз.\n\n*for Цикл for выполняет блок кода фиксированное количество раз.\n*while Цикл while выполняет блок кода, пока условие истинно.\n*do while Цикл do while выполняет блок кода хотя бы один раз, а затем продолжает выполнение, пока условие истинно.\n\n3. Управляющие операторы\n*break Оператор break используется для выхода из цикла или оператора switch.\n*continue Оператор continue пропускает текущую итерацию цикла и переходит к следующей.\n*return (возврат значения) Используется для возврата значения из функции.\n\n4. Обработка исключений\n*try (попытка обработки) Используется для оборачивания кода, который может вызвать исключение.\n*catch (перехват исключения) Обрабатывает исключение, если оно было выброшено в блоке try.\n*finally (блок завершения) Блок кода, который выполняется после try и catch, независимо от того, было ли выброшено исключение.\n*throw (генерация исключения) Используется для явного выбрасывания исключения.\n*rethrow (повторная генерация исключения) Позволяет повторно выбросить перехваченное исключение.')
        },
        'Widgets (Виджеты)': {
          'Stateless Widgets (Статические виджеты без состояния)': CategoryDetail([
            'Text (Текст)',
            'Icon (Иконка)',
            'Image (Изображение)',
            'Container (Контейнер)',
            'Column (Столбец)',
            'Row (Строка)',
            'Stack (Стек)',
            'Center (Центр)',
            'Padding (Отступ)',
            'Align (Выравнивание)',
            'Sized Box (Размеренный контейнер)',
            'Spacer (Пробел между)',
            'Divider (Разделитель)',
            'Placeholder (Заполнитель)',
            'Card (Карточка)',
          ],
              'StatelessWidget в Flutter представляет собой виджет, который не изменяет свое состояние во время жизненного цикла. Он отображает фиксированное значение, которое определяется в момент создания. Если требуется изменить отображение, необходимо создать новый экземпляр виджета с новыми данными.\nПреимущества Stateless Widgets\nПростота: Stateless виджеты легче в понимании и использовании, так как их поведение не изменяется.\nПроизводительность: Они менее ресурсоемкие по сравнению с StatefulWidget, так как не требуют управления состоянием.\nУдобство: Идеальны для простых и статических интерфейсов, таких как текстовые метки, иконки и статические карточки.'),
          'Stateful Widgets(Динамические виджеты с сохранением состояния)': CategoryDetail([
            'TextField (Текстовое поле)',
            'Checkbox (Флажок)',
            'Radio (Переключатель(радиокнопка))',
            'Switch(Переключатель(тумблер))',
            'Slider (Слайдер (ползунок))',
            'Form (Форма)',
            'AnimatedContainer (Анимированный контейнер)',
            'ListView (Прокручиваемый список)',
            'FutureBuilder',
            'StreamBuilder',
            'GestureDetector (Обнаружение жестов)',
            'Draggable (Перетаскиваемый элемент)',
            'BottomNavigationBar (Нижняя панель навигации)',
            'TabBar (Панель вкладок)',
          ],
              'StatefulWidget в Flutter — это тип виджета, который может изменять свое состояние во время жизненного цикла. Это делает его подходящим для отображения данных, которые могут динамически изменяться (например, счетчики, анимации, формы и другие элементы, которые требуют обновления интерфейса).'),
          'Inherited Widgets (Унаследованные виджеты)': CategoryDetail([
            'InheritedWidget (унаследованный виджет)',
            'InheritedModel (унаследованная модель)',
            'MediaQuery ( Информация о медиа-характеристиках устройства)',
            'Theme (тема)',
            'Navigator (навигатор)',
            'MaterialApp (Приложение на основе Material Design)',
            'CupertinoApp (Приложение на основе iOS-стиля (Cupertino))',
            'Provider (from the Provider package) (Провайдер из пакета Provider)',
            'InheritedNotifier (унаследованный уведомитель)',
            'StreamProvi﻿der (from the Provider package) (Stream-провайдер из пакета Provider)',
            'FuturePr﻿ovider (from the Provider package) (Future-провайдер из пакета Provider)',
          ],
              'InheritedWidget — это специальный тип виджета в Flutter, который позволяет передавать данные по дереву виджетов без необходимости напрямую передавать их через конструкторы. InheritedWidget предоставляет доступ к данным для всех дочерних виджетов, что делает его отличным выбором для управления состоянием, которое должно быть доступно многим виджетам в приложении.\nПринцип работы InheritedWidget\n\tОсновное назначение InheritedWidget — это предоставить данные или объекты состояния, которые могут быть доступны по дереву виджетов ниже. Когда данные в InheritedWidget изменяются, все виджеты, зависящие от этого состояния, автоматически пересоздаются для обновления интерфейса.'),
          'Responsive Widgets (Адаптивные виджеты)': CategoryDetail([
            'MediaQuery ( Информация о медиа-характеристиках устройства)',
            'LayoutBuilder (строитель макета)',
            'Flexible (гибкий)',
            'Expanded (расширенный)',
            'AspectRatio (соотношение сторон)',
            'FittedBox (вписанный виджет)',
            'ResponsiveBuilder (from the responsive_builder package) (ResponsiveBuilder из пакета responsive_builder)',
            'ScreenUtil (from the flutter_screenutil package) (ScreenUtil из пакета flutter_screenutil)',
            'SizedBox (размеренный виджет)',
            'OrientationBuilder (строитель ориентации)',
            'GridView (сетчатый виджет)',
            'ListView (виджет списка)',
            'Wrap (обертка)',
            'Column (столбец)',
            'Row (строка)',
          ],
              'Responsive Widgets в Flutter предназначены для создания интерфейсов, которые адаптируются под разные размеры экранов, ориентации и плотность пикселей. Этот подход позволяет обеспечить удобный и корректный вид приложения на разных устройствах, от маленьких телефонов до планшетов и больших экранов.\n\nОсновные методы создания адаптивного интерфейса\n1. LayoutBuilder: Используется для создания виджетов на основе размеров родительского контейнера. Это полезно для создания адаптивного интерфейса в зависимости от текущей ширины экрана.\n2. MediaQuery: Предоставляет информацию о размере экрана, ориентации и других характеристиках устройства. С помощью MediaQuery можно менять структуру интерфейса на основе данных устройства.\n3. Flexible и Expanded: Эти виджеты позволяют дочерним элементам занимать оставшееся пространство в контейнере, что помогает обеспечить адаптивность. Flexible позволяет элементу адаптироваться к доступному пространству, а Expanded занимает все доступное пространство.\n4. AspectRatio: Устанавливает соотношение сторон для виджета, сохраняя пропорции на разных размерах экранов.\n5. OrientationBuilder: Изменяет интерфейс в зависимости от ориентации экрана (портретной или ландшафтной).\n6. FittedBox (Вписанный виджет): Масштабирует дочерний элемент до максимально возможного размера в пределах родительского контейнера, сохраняя пропорции.\n7. ResponsiveBuilder (из пакета responsive_builder): Упрощает создание адаптивных интерфейсов, автоматически подстраиваясь под разные экраны.\n8. ScreenUtil (из пакета flutter_screenutil): Позволяет устанавливать размеры и отступы, которые адаптируются к размеру экрана. Это полезно для обеспечения масштабируемости на разных устройствах.\n9. SizedBox (Размеренный виджет): Виджет для создания ограниченного пространства, который помогает задавать фиксированную ширину или высоту элемента.\n10. GridView (Сетчатый виджет): Виджет для создания прокручиваемой сетки элементов, что особенно полезно при создании галерей или таблиц.\n11. ListView (Виджет списка): Прокручиваемый список элементов, который полезен для отображения большого количества данных.\n12. Wrap (Обертка): Виджет, который автоматически переносит дочерние элементы на новую строку или столбец, если нет места в текущем ряду или столбце.\n13. Column (Столбец): Располагает элементы вертикально. Удобен для создания вертикальных компоновок.\n14. Row (Строка): Располагает элементы горизонтально, создавая структуру для горизонтальной компоновки.'),
          'Styled Material Widgets (Стилизованные Material виджеты)': CategoryDetail([
            'MaterialApp (Приложение на основе Material Design)',
            'Scaffold (каркас)',
            'AppBar (панель приложения)',
            'Drawer (выдвижное меню)',
            'BottomNavigationBar (нижняя навигационная панель)',
            'FloatingActionButton (плавающая кнопка действия)',
            'Card (карточка)',
            'Chip (чип)',
            'Dialog (диалог)',
            'SnackBar (снэк-бар)',
            'IconButton (кнопка с иконкой)',
            'Tooltip (подсказка)',
            'TextButton (кнопка с текстом)',
            'ElevatedButton (высокая кнопка)',
            'OutlinedButton (кнопка с обводкой)',
          ],
              'Styled Material Widgets — это набор виджетов в Flutter, которые используют стилизацию и тему Material Design для обеспечения согласованного интерфейса, поддерживая цвета, размеры и стили согласно дизайн-системе Google. С их помощью можно настраивать элементы интерфейса для соответствия вашему уникальному стилю, сохраняя знакомый пользователям опыт.\n\nОсновные виджеты и стили Material Design:\n1. MaterialApp (Приложение на основе Material Design): Корневой виджет приложения, предоставляющий темы и маршрутизацию. Настройка MaterialApp позволяет задать основную тему, маршруты, начальный экран и другие параметры, определяющие общий стиль приложения.\n2. Scaffold (Каркас): Базовый контейнер для экрана, обеспечивающий структуру и компоненты, такие как AppBar, Drawer, BottomNavigationBar, и FloatingActionButton. Scaffold задаёт основу для интерфейса, автоматически обрабатывая такие элементы, как клавиатура и прокрутка.\n3. AppBar (Панель приложения): Верхняя панель с заголовком, иконками и кнопками действий. Можно стилизовать цвет фона, тени, элементы, а также добавить логотип или иконку меню.\n4. Drawer (Выдвижное меню): Боковое меню навигации, которое можно открывать свайпом или с помощью иконки в AppBar. Drawer позволяет пользователям быстро переключаться между разделами приложения.\n5. BottomNavigationBar (Нижняя навигационная панель): Панель навигации в нижней части экрана, позволяющая пользователям переключаться между основными разделами приложения. Каждый элемент навигации может иметь иконку и подпись.\n6. FloatingActionButton (Плавающая кнопка действия): Круглая кнопка для основных действий на странице. Можно изменить цвет, иконку и форму.\n7. Card (Карточка): Контейнер с тенями и закруглёнными углами, применяемый для визуального отделения информации в списках, профилях или новостях. Card поддерживает стилизацию с заданием цвета и границ.\n8. Chip (Чип): Компактный элемент, используемый для отображения короткой информации, тегов или контактов. Чипы часто применяются для фильтров, иконок и текста в ограниченном пространстве.\n9. Dialog (Диалог): Всплывающее окно для отображения информации, подтверждений или запросов к пользователю. Dialog содержит элементы заголовка, основного текста и действий. Существуют несколько видов диалогов, таких как AlertDialog и SimpleDialog.\n10. SnackBar (Снэк-бар): Краткое уведомление, которое временно отображается внизу экрана. SnackBar используется для отображения сообщений о статусе или подтверждений действий.\n11. IconButton (Кнопка с иконкой): Кнопка, отображающая иконку вместо текста. Часто используется в AppBar для создания действий. IconButton можно стилизовать, задав цвет, размер и внешний вид иконки.\n12. Tooltip (Подсказка): Небольшое текстовое окно, которое появляется при долгом нажатии на элемент и отображает дополнительную информацию. Tooltip помогает объяснить действие или цель элементов интерфейса.\n13. TextButton (Кнопка с текстом): Кнопка без фона, содержащая только текст. Обычно применяется для вторичных действий и может быть стилизована с использованием цвета текста и эффектов.\n14. ElevatedButton (Приподнятая кнопка): Кнопка с приподнятым эффектом, настраиваемая по цвету фона, текста и форме.\n15. OutlinedButton (Кнопка с обводкой): Кнопка с контуром вместо фона, используется для менее акцентных действий. OutlinedButton может быть настроена с цветом контура и текста.'),
          'Styled Cupertino widgets (Стилизованные Cupertino виджеты)': CategoryDetail([
            'CupertinoApp (Приложение на основе iOS-стиля (Cupertino))',
            'CupertinoNavigationBar (Cupertino-навигационная панель)',
            'CupertinoTabBar (Cupertino-вкладки)',
            'CupertinoButton (Cupertino-кнопка)',
            'CupertinoSlider (Cupertino-слайдер)',
            'CupertinoSwitch (Cupertino-переключатель)',
            'CupertinoScrollbar (Cupertino-скроллбар)',
          ],
              'Набор виджетов Cupertino в Flutter создаёт интерфейсы, стилизованные под iOS. Эти виджеты помогают сделать ваше приложение более адаптированным к стилю и поведению iOS и идеальны для платформенно-ориентированного подхода.\n\nОсновные виджеты и стили Cupertino:\n1. CupertinoApp (Приложение на основе iOS-стиля): Основной виджет для создания приложения в стиле iOS. Похож на MaterialApp, но с настройками и стилями, характерными для iOS. Управляет навигацией, темами и локализацией.\n2. CupertinoNavigationBar (Cupertino-навигационная панель): Верхняя панель в стиле iOS для отображения заголовка и кнопок навигации. Можно стилизовать цвета и содержимое.\n3. CupertinoTabBar (Cupertino-вкладки): Нижняя панель вкладок в стиле iOS для переключения между разделами приложения. Можно стилизовать по цвету, размеру значков и тексту.\n4. CupertinoButton (Cupertino-кнопка): Кнопка, стилизованная для iOS, с настраиваемым цветом, текстом и размером.\n5. CupertinoSlider (Cupertino-слайдер): Слайдер для выбора значений в диапазоне. Стилизуется по цвету активной полоски и положению ползунка.\n6. CupertinoSwitch (Cupertino-переключатель): Переключатель, который позволяет включать или отключать опцию. Стилизуется по цвету активного состояния.\n7. CupertinoScrollbar (Cupertino-скроллбар): Полоса прокрутки в стиле iOS для улучшения навигации по длинным спискам. Виджет автоматически отображается при скроллинге и может быть стилизован.')
        },
        'Assets (Ассеты)': {
          'Fonts (шрифты)': CategoryDetail([],
              'Assets в Flutter — это файлы, используемые вашим приложением, такие как изображения, шрифты, звуки и другие ресурсы. Эти файлы загружаются в приложение и могут быть использованы для создания пользовательского интерфейса и взаимодействия.\n\nОсновные виды ассетов:\n1. Изображения: Изображения могут быть в форматах PNG, JPEG, GIF и других. Их можно использовать для отображения графики в приложении.\n2. Шрифты: Шрифты добавляются в проект для использования в текстовых виджетах. Можно включить пользовательские шрифты в приложение.\n3. Звуковые файлы: Звуковые файлы, такие как MP3 или WAV, могут быть добавлены для воспроизведения звуковых эффектов или музыки в приложении.\n4. Данные в формате JSON: JSON файлы могут использоваться для хранения и загрузки конфигураций, настроек или данных в приложении.'),
          'Images(Изображения)': CategoryDetail([],
              'Assets в Flutter — это файлы, используемые вашим приложением, такие как изображения, шрифты, звуки и другие ресурсы. Эти файлы загружаются в приложение и могут быть использованы для создания пользовательского интерфейса и взаимодействия.\n\nОсновные виды ассетов:\n1. Изображения: Изображения могут быть в форматах PNG, JPEG, GIF и других. Их можно использовать для отображения графики в приложении.\n2. Шрифты: Шрифты добавляются в проект для использования в текстовых виджетах. Можно включить пользовательские шрифты в приложение.\n3. Звуковые файлы: Звуковые файлы, такие как MP3 или WAV, могут быть добавлены для воспроизведения звуковых эффектов или музыки в приложении.\n4. Данные в формате JSON: JSON файлы могут использоваться для хранения и загрузки конфигураций, настроек или данных в приложении.'),
          'Other files(Другие файлы)': CategoryDetail([],
              'Assets в Flutter — это файлы, используемые вашим приложением, такие как изображения, шрифты, звуки и другие ресурсы. Эти файлы загружаются в приложение и могут быть использованы для создания пользовательского интерфейса и взаимодействия.\n\nОсновные виды ассетов:\n1. Изображения: Изображения могут быть в форматах PNG, JPEG, GIF и других. Их можно использовать для отображения графики в приложении.\n2. Шрифты: Шрифты добавляются в проект для использования в текстовых виджетах. Можно включить пользовательские шрифты в приложение.\n3. Звуковые файлы: Звуковые файлы, такие как MP3 или WAV, могут быть добавлены для воспроизведения звуковых эффектов или музыки в приложении.\n4. Данные в формате JSON: JSON файлы могут использоваться для хранения и загрузки конфигураций, настроек или данных в приложении.')
        },
        'Git (Гит)': {
          'GitHub': CategoryDetail([],
              'Git — это распределённая система управления версиями, используемая для отслеживания изменений в исходном коде и координации работы над проектами. Git позволяет разработчикам работать совместно, сохранять историю изменений и восстанавливать предыдущие версии файлов.\n\nОсновные понятия Git:\n1. Репозиторий (Repository): Это место, где хранится весь проект, включая файлы, папки и историю изменений. Репозиторий может быть локальным (на вашем компьютере) или удалённым (например, на GitHub, GitLab и т. д.).\n2. Коммит (Commit): Это фиксированное состояние файлов в репозитории. Каждый коммит содержит сообщение, описывающее изменения, и уникальный идентификатор.\n3. Ветка (Branch): Ветка — это независимая линия разработки. Она позволяет вам работать над новыми функциями или исправлениями, не затрагивая основную (обычно main или master) ветку.\n4. Слияние (Merge): Слияние — это процесс объединения изменений из одной ветки в другую. Обычно сливаются изменения из ветки функции в основную ветку.\n5. Удалённый репозиторий (Remote Repository): Это версия вашего репозитория, размещённая на сервере. Вы можете взаимодействовать с удалённым репозиторием для совместной работы с другими разработчиками.\n6. Пулл (Pull): Команда, которая позволяет загрузить изменения из удалённого репозитория и объединить их с вашей локальной веткой.\n7. Пуш (Push): Команда, которая отправляет ваши локальные коммиты в удалённый репозиторий.'),
          'GitLab': CategoryDetail([],
              'Git — это распределённая система управления версиями, используемая для отслеживания изменений в исходном коде и координации работы над проектами. Git позволяет разработчикам работать совместно, сохранять историю изменений и восстанавливать предыдущие версии файлов.\n\nОсновные понятия Git:\n1. Репозиторий (Repository): Это место, где хранится весь проект, включая файлы, папки и историю изменений. Репозиторий может быть локальным (на вашем компьютере) или удалённым (например, на GitHub, GitLab и т. д.).\n2. Коммит (Commit): Это фиксированное состояние файлов в репозитории. Каждый коммит содержит сообщение, описывающее изменения, и уникальный идентификатор.\n3. Ветка (Branch): Ветка — это независимая линия разработки. Она позволяет вам работать над новыми функциями или исправлениями, не затрагивая основную (обычно main или master) ветку.\n4. Слияние (Merge): Слияние — это процесс объединения изменений из одной ветки в другую. Обычно сливаются изменения из ветки функции в основную ветку.\n5. Удалённый репозиторий (Remote Repository): Это версия вашего репозитория, размещённая на сервере. Вы можете взаимодействовать с удалённым репозиторием для совместной работы с другими разработчиками.\n6. Пулл (Pull): Команда, которая позволяет загрузить изменения из удалённого репозитория и объединить их с вашей локальной веткой.\n7. Пуш (Push): Команда, которая отправляет ваши локальные коммиты в удалённый репозиторий.'),
          'BitBucket': CategoryDetail([],
              'Git — это распределённая система управления версиями, используемая для отслеживания изменений в исходном коде и координации работы над проектами. Git позволяет разработчикам работать совместно, сохранять историю изменений и восстанавливать предыдущие версии файлов.\n\nОсновные понятия Git:\n1. Репозиторий (Repository): Это место, где хранится весь проект, включая файлы, папки и историю изменений. Репозиторий может быть локальным (на вашем компьютере) или удалённым (например, на GitHub, GitLab и т. д.).\n2. Коммит (Commit): Это фиксированное состояние файлов в репозитории. Каждый коммит содержит сообщение, описывающее изменения, и уникальный идентификатор.\n3. Ветка (Branch): Ветка — это независимая линия разработки. Она позволяет вам работать над новыми функциями или исправлениями, не затрагивая основную (обычно main или master) ветку.\n4. Слияние (Merge): Слияние — это процесс объединения изменений из одной ветки в другую. Обычно сливаются изменения из ветки функции в основную ветку.\n5. Удалённый репозиторий (Remote Repository): Это версия вашего репозитория, размещённая на сервере. Вы можете взаимодействовать с удалённым репозиторием для совместной работы с другими разработчиками.\n6. Пулл (Pull): Команда, которая позволяет загрузить изменения из удалённого репозитория и объединить их с вашей локальной веткой.\n7. Пуш (Push): Команда, которая отправляет ваши локальные коммиты в удалённый репозиторий.')
        },
        'Packet Manager (Менеджер пакетов)': {
          'Pub Dev ( Центральный репозиторий пакетов для Flutter и Dart)': CategoryDetail([],
              'Pub Dev — это центральный репозиторий для пакетов и библиотек, разработанных на Dart и Flutter. Он предоставляет разработчикам возможность находить, использовать и делиться пакетами с сообществом.\n\nОсновные функции Pub Dev:\n1. Поиск пакетов: Разработчики могут легко искать и находить нужные пакеты с помощью различных фильтров и категорий.\n2. Документация: Каждому пакету предоставляется документация, которая описывает его функции и методы использования.\n3. Статистика: Pub Dev показывает статистику использования пакетов, включая количество загрузок, поддерживаемые версии Dart и Flutter.\n4. Рейтинг и отзывы: Пользователи могут оставлять отзывы и ставить рейтинги, что помогает другим разработчикам принимать обоснованные решения о выборе пакетов.\n5. Версионирование: Pub Dev поддерживает версионирование пакетов, что позволяет разработчикам легко обновлять свои зависимости до последних стабильных версий.'),
          'Package stored on Git repo (пакет, хранящийся в репозитории Git)': CategoryDetail([],
              'Пакеты, хранящиеся в репозиториях Git, позволяют разработчикам использовать код, который хранится в системах контроля версий, таких как GitHub, GitLab или Bitbucket. Это особенно полезно для работы с собственными пакетами или пакетами, которые еще не опубликованы на Pub Dev.\n\nОсновные моменты:\n1. Подключение к репозиторию: Чтобы использовать пакет из Git-репозитория, разработчики могут указать URL-адрес репозитория в своем pubspec.yaml.\n2. Управление версиями: Можно указать конкретные ветки, теги или коммиты, что позволяет точно контролировать используемую версию.\n3. Преимущества: Использование пакетов из Git позволяет легко вносить изменения в код, тестировать его и делиться с командой, не дожидаясь публикации на Pub Dev.'),
          'Local package (локальный пакет)': CategoryDetail([],
              'Локальные пакеты — это пакеты, которые хранятся на вашем компьютере, а не в удаленных репозиториях. Это удобно для разработки и тестирования пакетов, которые еще не опубликованы или когда необходимо внести изменения в код пакета.\n\nОсновные моменты:\n1. Использование локального пакета: Чтобы подключить локальный пакет, разработчики могут указать путь к директории в своем pubspec.yaml.\n2. Удобство: Локальные пакеты позволяют разработчикам быстро вносить изменения и тестировать их без необходимости постоянного обновления или публикации.\n3. Тестирование: Это идеальный способ тестирования новых функций и исправлений ошибок перед их отправкой в удаленный репозиторий или публикацией на Pub Dev.')
        },
        'Design Principle (Принцип проектирования)': {
          'OOP (ООП)': CategoryDetail([
            'Classes and Objects (классы и объекты)',
            'Constructors (конструкторы)',
            'Instance Variables (переменные экземпляра)',
            'Methods (методы)',
            'Inheritance (наследование)',
            'Polymorphism (полиморфизм)',
            'Encapsulation (инкапсуляция)',
            'Abstraction (абстракция)',
            'Interfaces (интерфейсы)',
            'Mixins (миксины)',
            'Static Members (статические члены)',
            'Getters and Setters (геттеры и сеттеры)',
          ],
              'Объектно-ориентированное программирование (OOP) — это парадигма программирования, основанная на концепциях "объектов", которые могут содержать данные и код: данные в виде полей (атрибутов или свойств), а код в виде процедур (методов). OOP помогает структурировать программы более интуитивно, позволяя моделировать реальные объекты и взаимодействия.\nОписание:\nКласс — это шаблон для создания объектов, который определяет свойства (данные) и методы (функции), которые будут доступны каждому объекту. Объект — это экземпляр класса, который имеет свое состояние и поведение. Например, класс Car может содержать свойства, такие как color и model, и методы, такие как drive() и stop().\n\n2. Constructors (Конструкторы)\nОписание:\nКонструкторы — это специальные методы, которые вызываются при создании объекта. Они инициализируют свойства объекта и могут принимать параметры для задания начальных значений. Например, в классе Person конструктор может принимать имя и возраст как параметры.\n\n3. Instance Variables (Переменные экземпляра)\nОписание:\nПеременные экземпляра — это поля класса, которые хранят состояние каждого объекта. Каждое значение переменной экземпляра уникально для каждого объекта. Например, у двух объектов класса Dog могут быть разные имена и породы, хранящиеся в переменных экземпляра name и breed.\n\n4. Methods (Методы)\nОписание:\nМетоды — это функции, определенные внутри класса, которые описывают поведение объектов. Методы могут изменять состояние объекта, выполнять действия или возвращать значения. Например, метод bark() в классе Dog может выводить звук лая.\n\n5. Inheritance (Наследование)\nОписание:\nНаследование позволяет создавать новый класс на основе существующего. Производный класс наследует свойства и методы родительского класса, что позволяет повторно использовать код. Например, класс Animal может быть родительским классом для классов Dog и Cat.\n\n6. Polymorphism (Полиморфизм)\nОписание:\nПолиморфизм позволяет объектам разных классов использовать один и тот же интерфейс для выполнения действий. Это достигается через переопределение методов. Например, метод makeSound() может быть определен в классах Dog и Cat, но каждый класс будет реализовывать его по-своему.\n\n7. Encapsulation (Инкапсуляция)\nОписание:\nИнкапсуляция — это механизм, позволяющий скрыть внутреннее состояние объекта от внешнего мира и управлять доступом к нему через методы. Это помогает защитить данные и предотвращает их некорректное изменение. Например, поля класса могут быть приватными, а доступ к ним осуществляется через публичные методы.\n\n8. Abstraction (Абстракция)\nОписание:\nАбстракция позволяет выделить общие характеристики объектов и скрыть детали реализации. Это упрощает работу с объектами и помогает сосредоточиться на основном функционале. Например, интерфейсы и абстрактные классы помогают разработать четкие контракты для классов, не задумываясь о реализации.\n\n9. Interfaces (Интерфейсы)\nОписание:\nИнтерфейсы определяют набор методов, которые классы должны реализовать, но не содержат реализаций. Это позволяет создавать обобщенные структуры и использовать полиморфизм. Например, интерфейс Flyable может быть реализован классами Bird и Airplane, каждый из которых имеет свою реализацию метода fly().\n\n10. Mixins (Миксины)\nОписание:\nМиксины — это специальные классы, которые могут быть использованы для добавления функциональности к другим классам без необходимости наследования. Это позволяет повторно использовать код и добавлять новые возможности. Например, миксин Logger может добавлять метод для логирования сообщений в любой класс, который его использует.\n\n11. Static Members (Статические члены)\nОписание:\nСтатические члены класса (переменные и методы) принадлежат классу, а не его экземплярам. Они могут быть вызваны без создания объекта класса. Например, статическая переменная count может отслеживать количество созданных объектов данного класса.\n\n12. Getters and Setters (Геттеры и сеттеры)\nОписание:\nГеттеры и сеттеры — это специальные методы, используемые для доступа и изменения приватных переменных экземпляра. Геттеры возвращают значение переменной, а сеттеры устанавливают его. Это позволяет контролировать доступ к данным и выполнять дополнительные действия при изменении значений. Например, сеттер может проверять корректность входных данных перед установкой значения.'),
          'SOLID principles (Принципы SOLID)': CategoryDetail([
            'Single Responsibility Principle (SRP) (Принцип единственной ответственности)',
            'Open/Closed Principle (OCP) (Принцип открытости/закрытости)',
            'Liskov Substitution Principle (LSP) (Принцип подстановки Барбары Лисков)',
            'Interface Segregation Principle (ISP) (Принцип разделения интерфейса)',
            'Dependency Inversion Principle (DIP) (Принцип инверсии зависимостей)',
          ],
              '1. Single Responsibility Principle (SRP) (Принцип единственной ответственности)\nОписание:\nКаждый класс должен иметь только одну причину для изменения, то есть должен иметь только одну ответственность. Это означает, что класс должен выполнять только одну задачу или функциональность. Например, класс ReportGenerator отвечает только за генерацию отчетов, в то время как класс ReportPrinter отвечает только за печать отчетов. Это упрощает сопровождение и тестирование кода.\n\n2. Open/Closed Principle (OCP) (Принцип открытости/закрытости)\nОписание:\nКлассы должны быть открыты для расширения, но закрыты для модификации. Это означает, что вы должны иметь возможность добавлять новые функциональные возможности к существующему коду без изменения его. Например, вместо изменения класса Shape для добавления новых фигур, вы можете создать новый класс Circle, который наследует от Shape и реализует его методы.\n\n3. Liskov Substitution Principle (LSP) (Принцип подстановки Лисков)\nОписание:\nОбъекты базового класса должны быть заменяемы объектами производных классов без изменения правильности программы. Это подразумевает, что производные классы должны поддерживать контракт базового класса. Например, если класс Bird имеет метод fly(), производный класс Penguin, который не может летать, не должен наследовать этот метод. Вместо этого следует создать другой интерфейс или базовый класс, чтобы избежать нарушений принципа.\n\n4. Interface Segregation Principle (ISP) (Принцип разделения интерфейсов)\nОписание:\nКлиенты не должны зависеть от интерфейсов, которые они не используют. Вместо одного общего интерфейса следует создавать несколько специализированных интерфейсов. Это позволяет уменьшить зависимость классов и облегчает их тестирование. Например, вместо одного интерфейса Animal с методами walk(), fly() и swim(), лучше создать интерфейсы Walker, Flyer и Swimmer, чтобы разные классы могли реализовывать только нужные методы.\n\n5. Dependency Inversion Principle (DIP) (Принцип инверсии зависимостей)\nОписание:\nМодули высшего уровня не должны зависеть от модулей низшего уровня; обе группы должны зависеть от абстракций. Кроме того, абстракции не должны зависеть от деталей; детали должны зависеть от абстракций. Это означает, что следует использовать интерфейсы или абстрактные классы для определения зависимостей, чтобы минимизировать связность. Например, вместо создания экземпляра класса Database внутри класса UserService, лучше передавать интерфейс IDatabase в конструктор UserService, чтобы обеспечить гибкость и возможность тестирования.'),
          'Design pattern (Шаблон проектирования)': CategoryDetail([
            'Singleton (Одиночное использование)',
            'Factory (фабричный конструктор)',
            'Builder (Строитель)',
            'Adapter (Адаптер)',
            'Observer (Наблюдатель)',
            'Repository (Репозиторий)',
            'Model-View-ViewModel (MVVM) (Модель-Представление)',
            'Provider (State Management)',
            'Bloc (Business Logic Component)',
            'Decorator (Декоратор)',
            'Command (Команда)',
            'Dependency Injection (DI) (Внедрение зависимосетей)',
            'Facade (Фасад)',
            'Strategy (Стратегия)',
          ],
              '1. Singleton (Одиночное использование)\nОписание:\nШаблон, который гарантирует, что класс имеет только один экземпляр и предоставляет глобальную точку доступа к этому экземпляру. Он полезен, когда необходимо управлять общим состоянием или ресурсами, например, настройками приложения или подключениями к базе данных.\n\n2. Factory Method (Фабричный метод)\nОписание:\nШаблон, который предоставляет интерфейс для создания объектов, не указывая их конкретный класс. Это позволяет делегировать создание объектов подклассам, что упрощает код и его поддержку.\n\n3. Builder (Строитель)\nОписание:\nШаблон, который разделяет процесс создания сложного объекта на несколько этапов. Он позволяет пошагово настраивать объект и скрывает детали реализации. Это удобно для создания объектов с множеством опциональных параметров.\n\n4. Adapter (Адаптер)\nОписание:\nШаблон, который позволяет объектам с несовместимыми интерфейсами работать вместе. Адаптер оборачивает интерфейс одного класса, чтобы соответствовать интерфейсу другого, что обеспечивает взаимодействие между различными системами.\n\n5. Observer (Наблюдатель)\nОписание:\nШаблон, который определяет зависимость \"один ко многим\" между объектами, так что при изменении состояния одного объекта все его зависимые объекты уведомляются и обновляются автоматически. Это полезно для реализации паттерна \"издатель-подписчик\".\n\n6. Repository (Репозиторий)\nОписание:\nШаблон, который обеспечивает абстракцию доступа к данным, позволяя отделить бизнес-логику от логики доступа к данным. Репозиторий предоставляет интерфейс для выполнения операций CRUD (создание, чтение, обновление, удаление) и управления жизненным циклом объектов.\n\n7. Model-View-ViewModel (MVVM) (Модель-Представление)\nОписание:\nШаблон проектирования, который разделяет логику пользовательского интерфейса на три компонента: Модель (данные), Представление (UI) и Модель представления (логика обработки). Это упрощает тестирование и управление состоянием приложения.\n\n8. Provider (State Management) (Управление состоянием)\nОписание:\nШаблон, который используется для управления состоянием в приложении. Он позволяет разделять логику состояния и представление, что делает код более чистым и простым в сопровождении. Обычно используется с помощью ChangeNotifier.\n\n9. Bloc (Business Logic Component) (Бизнес-логика компонента)\nОписание:\nШаблон, который помогает организовать бизнес-логику в приложении, используя потоки (Streams) и события. Это позволяет отделить логику от пользовательского интерфейса и упростить тестирование.\n\n10. Decorator (Декоратор)\nОписание:\nШаблон, который позволяет динамически добавлять новые функциональные возможности к объектам, не изменяя их структуру. Декораторы обеспечивают гибкость в расширении функциональности, позволяя комбинировать различные объекты.\n\n11. Command (Команда)\nОписание:\nШаблон, который превращает запросы в объекты, позволяя параметризовать клиентов с различными запросами, ставить запросы в очередь и логировать их. Он также поддерживает отмену операций.\n\n12. Dependency Injection (DI) (Внедрение зависимостей)\nОписание:\nШаблон, который позволяет передавать зависимости объектам, вместо их создания внутри объекта. Это улучшает тестируемость и уменьшает связанность между компонентами приложения.\n\n13. Facade (Фасад)\nОписание:\nШаблон, который предоставляет унифицированный интерфейс к набору интерфейсов в подсистеме. Фасад упрощает использование сложных систем, скрывая детали реализации и предоставляя более простой интерфейс.\n\n14. Strategy (Стратегия)\nОписание:\nШаблон, который позволяет определять семейство алгоритмов, инкапсулировать каждый из них и делать их взаимозаменяемыми. Это позволяет изменять алгоритмы независимо от клиентов, которые их используют.')
        },
        'Storage (Хранилище)': {
          'Shared Preferences': CategoryDetail([],
              'Shared Preferences — это простой способ хранения небольших объемов данных, таких как настройки или пользовательские предпочтения, в виде пар "ключ-значение". Это удобно для хранения простых данных, таких как логины, настройки интерфейса и другие параметры.'),
          'SQLite': CategoryDetail([],
              'Локальные базы данных, такие как SQLite, используются для хранения структурированных данных в виде таблиц. Flutter поддерживает работу с SQLite через такие пакеты, как sqflite и moor. Это позволяет создавать, читать, обновлять и удалять данные на устройстве.'),
          'Firebase': CategoryDetail([],
              'Для хранения данных на удаленных серверах можно использовать облачные решения, такие как Firebase Cloud Storage. Это позволяет загружать и загружать файлы из облака, а также работать с большими объемами данных, не занимая место на устройстве пользователя.')
        },
        'API (Программный интерфейс приложения )': {
          'REST': CategoryDetail([],
              'REST (Representational State Transfer) — это архитектурный стиль, основанный на HTTP, который используется для разработки веб-сервисов. RESTful API использует стандартные HTTP методы (GET, POST, PUT, DELETE) для выполнения операций над ресурсами. В Flutter взаимодействие с RESTful API часто осуществляется с помощью пакета http или Dio.'),
          'GraphQL': CategoryDetail([],
              'GraphQL — это язык запросов для API, который предоставляет клиентам возможность запрашивать только те данные, которые им нужны. В отличие от REST, где каждое обращение к API возвращает фиксированный набор данных, в GraphQL вы можете гибко задавать структуру ответа. Для работы с GraphQL в Flutter можно использовать пакеты, такие как graphql_flutter.'),
          'Web Sockets': CategoryDetail([],
              'WebSockets — это протокол для двусторонней связи между клиентом и сервером через единственное соединение. Он позволяет обмениваться данными в режиме реального времени, что делает его идеальным для приложений, которые требуют мгновенной передачи данных, таких как чаты, игры, или финансовые приложения.')
        },
        'Advanced Dart (Продвинутый Dart)': {
          'Core Package (Основной пакет)': CategoryDetail([],
              'Core Package (Основной пакет)\nОсновной пакет Dart содержит базовые библиотеки, которые предоставляют функциональность, необходимую для разработки приложений. Это включает в себя работу с числами, строками, коллекциями и асинхронным программированием. Библиотеки, такие как dart:core, являются частью каждого Dart-приложения и предоставляют основные классы и функции, которые используются во всех приложениях.\n\nОсновные компоненты:\nString: для работы со строками.\nNum: для работы с числовыми значениями.\nList, Set, Map: для работы с коллекциями данных.'),
          'Collections (Коллекции)': CategoryDetail([],
              'Collections (Коллекции)\nКоллекции в Dart представляют собой структуры данных, которые позволяют хранить и обрабатывать группы объектов. Dart предоставляет несколько типов коллекций, включая списки (List), множества (Set) и ассоциативные массивы (Map). Каждая из этих коллекций имеет свои особенности и методы.\n\nПримеры:\nList: упорядоченная коллекция, которая может содержать дубликаты.\nSet: неупорядоченная коллекция уникальных элементов.\nMap: коллекция пар \"ключ-значение\".'),
          'lambdas (Лямбды)': CategoryDetail([],
              'Lambdas (Лямбды)\nЛямбда-функции, или анонимные функции, позволяют создавать функции без имени, которые могут быть переданы как аргументы или присвоены переменным. Это полезно для упрощения кода и уменьшения его избыточности, особенно в функциональном программировании.'),
          'Async/Await (асинхронность/ожидание)': CategoryDetail([],
              'Async/Await (Асинхронность/Ожидание)\nAsync/Await в Dart упрощает работу с асинхронным кодом. Использование ключевого слова async перед функцией позволяет вам использовать await для асинхронных операций, что делает код более читаемым и похожим на синхронный.'),
          'Isolate (Изоляты)': CategoryDetail([],
              'Isolate (Изоляты)\nИзоляты в Dart предоставляют возможность параллельного выполнения кода. Каждая изоляция имеет собственную память и не может напрямую взаимодействовать с другими изоляциями, что обеспечивает безопасность при многопоточном выполнении. Это позволяет избежать проблем, связанных с синхронизацией.')
        },
        'State Management (Управление состоянием)': {
          'Provider': CategoryDetail([],
              'Provider — это библиотека для управления состоянием, основанная на InheritedWidget, но упрощающая процесс. Она позволяет легко делиться состоянием между виджетами и автоматически управляет подписками на изменения состояния.'),
          'Bloc': CategoryDetail([],
              'Bloc (Business Logic Component) — это архитектурный паттерн, который разделяет бизнес-логику и интерфейс пользователя. Он использует потоки (Streams) для передачи состояния и событий, что позволяет управлять сложным состоянием приложения более предсказуемо.'),
          'Redux': CategoryDetail([],
              'Redux — это библиотека для управления состоянием, вдохновленная одноименной библиотекой JavaScript. Она предлагает централизованное хранилище (store), которое управляет состоянием приложения, используя строгий однонаправленный поток данных. Redux разделяет приложение на три основные части: состояния, действия и редьюсеры, что способствует предсказуемости и тестируемости.'),
          'GetX': CategoryDetail([],
              'GetX — это библиотека, предоставляющая удобные и мощные инструменты для управления состоянием, маршрутизацией и зависимостями. Она предлагает простой и интуитивно понятный API, поддерживает реактивное программирование и фокусируется на высокой производительности. GetX позволяет разработчикам легко управлять состоянием с минимальным количеством кода и высокой эффективностью.'),
          'Riverpod': CategoryDetail([],
              'Riverpod — это современный подход к управлению состоянием, который улучшает и упрощает использование Provider. Он предлагает более чистый способ управления состоянием и является более безопасным и эффективным.')
        },
        'Authentication (Аутентификация)': {
          'Firebase': CategoryDetail([],
              'Аутентификация — это процесс проверки подлинности пользователя или системы. В контексте мобильных приложений аутентификация позволяет пользователям входить в приложение, используя свои учетные данные, такие как имя пользователя и пароль, или другие методы, такие как социальные сети, биометрия (отпечаток пальца, распознавание лица) и одноразовые пароли (OTP).'),
          'Custom': CategoryDetail([],
              'Аутентификация — это процесс проверки подлинности пользователя или системы. В контексте мобильных приложений аутентификация позволяет пользователям входить в приложение, используя свои учетные данные, такие как имя пользователя и пароль, или другие методы, такие как социальные сети, биометрия (отпечаток пальца, распознавание лица) и одноразовые пароли (OTP).'),
        },
        'Push Notification (Push-уведомление)': {
          'Firebase': CategoryDetail([],
              'Пуш-уведомления — это сообщения, которые отправляются на устройство пользователя из сервера приложения, даже когда приложение не активно или закрыто. Они позволяют разработчикам взаимодействовать с пользователями, информировать их о новых событиях, акциях, обновлениях или другой важной информации.\n\nОсновные особенности пуш-уведомлений:\n1. Сигналы о новых событиях:\n\t\t*Пуш-уведомления могут использоваться для информирования пользователей о новых сообщениях, событиях или обновлениях, что помогает поддерживать их вовлеченность.\n\n2. Персонализация:\n\t\t*Уведомления могут быть персонализированы на основе интересов и поведения пользователя, что увеличивает вероятность их открытия.\n\n3. Повышение вовлеченности:\n\t\t*С помощью пуш-уведомлений можно напомнить пользователям о вашем приложении и увеличить его использование.\n\nИнтерактивные уведомления:\n\t\t*Некоторые уведомления могут содержать действия (например, кнопки), которые позволяют пользователю выполнять действия непосредственно из уведомления.\n\nFirebase Cloud Messaging (FCM) один из самых популярных способов реализации пуш-уведомлений в приложениях Flutter.\nПозволяет отправлять уведомления пользователям на Android и iOS.'),
          'Custom': CategoryDetail([],
              'Пуш-уведомления — это сообщения, которые отправляются на устройство пользователя из сервера приложения, даже когда приложение не активно или закрыто. Они позволяют разработчикам взаимодействовать с пользователями, информировать их о новых событиях, акциях, обновлениях или другой важной информации.\n\nОсновные особенности пуш-уведомлений:\n1. Сигналы о новых событиях:\n\t\t*Пуш-уведомления могут использоваться для информирования пользователей о новых сообщениях, событиях или обновлениях, что помогает поддерживать их вовлеченность.\n\n2. Персонализация:\n\t\t*Уведомления могут быть персонализированы на основе интересов и поведения пользователя, что увеличивает вероятность их открытия.\n\n3. Повышение вовлеченности:\n\t\t*С помощью пуш-уведомлений можно напомнить пользователям о вашем приложении и увеличить его использование.\n\nИнтерактивные уведомления:\n\t\t*Некоторые уведомления могут содержать действия (например, кнопки), которые позволяют пользователю выполнять действия непосредственно из уведомления.\n\nFirebase Cloud Messaging (FCM) один из самых популярных способов реализации пуш-уведомлений в приложениях Flutter.\nПозволяет отправлять уведомления пользователям на Android и iOS.'),
        },
        'Testing (Тестирование)': {
          'Unit Testing (Юнит тестирование)': CategoryDetail([],
              'Testing (Тестирование)\nОписание:\nТестирование — это процесс оценки функциональности приложения для обеспечения его корректности и надежности. В разработке на Flutter тестирование может включать в себя несколько уровней, включая юнит-тестирование, тестирование виджетов и интеграционное тестирование. Это позволяет разработчикам выявлять ошибки и проблемы на ранних стадиях, улучшая качество конечного продукта.\n\nОсновные типы тестирования в Flutter:\n1. Юнит-тестирование (Unit Testing):\n\n\t\t*Проверяет отдельные функции или методы на уровне кода.\n\t\t*Позволяет удостовериться, что каждая часть кода работает правильно изолированно от других.\n\t\t*Используется для тестирования бизнес-логики.\n\n2. Тестирование виджетов (Widget Testing):\n\n\t\t*Позволяет проверять пользовательский интерфейс (UI) и поведение виджетов.\n\t\t*Тесты выполняются в изолированной среде, позволяя имитировать пользовательские взаимодействия.\n\n3. Интеграционное тестирование (Integration Testing):\n\n\t\t*Проверяет взаимодействие между несколькими модулями и целыми приложениями.\n\t\t*Используется для оценки всей функциональности приложения в условиях, приближенных к реальным.'),
          'Widget Testing (Виджет-тест)': CategoryDetail([],
              'Testing (Тестирование)\nОписание:\nТестирование — это процесс оценки функциональности приложения для обеспечения его корректности и надежности. В разработке на Flutter тестирование может включать в себя несколько уровней, включая юнит-тестирование, тестирование виджетов и интеграционное тестирование. Это позволяет разработчикам выявлять ошибки и проблемы на ранних стадиях, улучшая качество конечного продукта.\n\nОсновные типы тестирования в Flutter:\n1. Юнит-тестирование (Unit Testing):\n\n\t\t*Проверяет отдельные функции или методы на уровне кода.\n\t\t*Позволяет удостовериться, что каждая часть кода работает правильно изолированно от других.\n\t\t*Используется для тестирования бизнес-логики.\n\n2. Тестирование виджетов (Widget Testing):\n\n\t\t*Позволяет проверять пользовательский интерфейс (UI) и поведение виджетов.\n\t\t*Тесты выполняются в изолированной среде, позволяя имитировать пользовательские взаимодействия.\n\n3. Интеграционное тестирование (Integration Testing):\n\n\t\t*Проверяет взаимодействие между несколькими модулями и целыми приложениями.\n\t\t*Используется для оценки всей функциональности приложения в условиях, приближенных к реальным.'),
          'Integration Testing (Интеграционное тестирование)': CategoryDetail([],
              'Testing (Тестирование)\nОписание:\nТестирование — это процесс оценки функциональности приложения для обеспечения его корректности и надежности. В разработке на Flutter тестирование может включать в себя несколько уровней, включая юнит-тестирование, тестирование виджетов и интеграционное тестирование. Это позволяет разработчикам выявлять ошибки и проблемы на ранних стадиях, улучшая качество конечного продукта.\n\nОсновные типы тестирования в Flutter:\n1. Юнит-тестирование (Unit Testing):\n\n\t\t*Проверяет отдельные функции или методы на уровне кода.\n\t\t*Позволяет удостовериться, что каждая часть кода работает правильно изолированно от других.\n\t\t*Используется для тестирования бизнес-логики.\n\n2. Тестирование виджетов (Widget Testing):\n\n\t\t*Позволяет проверять пользовательский интерфейс (UI) и поведение виджетов.\n\t\t*Тесты выполняются в изолированной среде, позволяя имитировать пользовательские взаимодействия.\n\n3. Интеграционное тестирование (Integration Testing):\n\n\t\t*Проверяет взаимодействие между несколькими модулями и целыми приложениями.\n\t\t*Используется для оценки всей функциональности приложения в условиях, приближенных к реальным.'),
        },
        'Dev Tools (Инструменты разработчика)': {
          'Flutter Inspector (Инструмент отладки)': CategoryDetail([],
              'Flutter Inspector — это инструмент, позволяющий разработчикам визуализировать и исследовать структуру виджетов в приложении. Он помогает анализировать и отлаживать интерфейс, показывая иерархию виджетов, их свойства и состояние.\nФункции:\n\t\t*Выбор виджетов: Позволяет выделять виджеты прямо на экране приложения для быстрого анализа их свойств и стилей.\n\t\t*Изменение свойств в реальном времени: Вы можете вносить изменения в свойства виджетов и сразу видеть результат на экране, что упрощает настройку интерфейса.\n\t\t*Проверка построения виджетов: Указывает на проблемы с построением виджетов, такие как переполнение или ошибки компоновки.'),
          'Flutter outline (Структурный обзор)': CategoryDetail([],
              'Flutter Outline предоставляет структурный обзор иерархии виджетов в приложении. Он показывает, как различные виджеты взаимосвязаны, и позволяет легко находить иерархические уровни.\nФункции:\n\t\t*Обзор структуры: Отображает полное дерево виджетов с их свойствами и состоянием, что упрощает понимание структуры интерфейса.\n\t\t*Поиск виджетов: Позволяет быстро находить и выбирать виджеты, что делает отладку и изменение интерфейса более эффективным.\n\t\t*Навигация: Упрощает навигацию по коду, показывая соответствие между иерархией виджетов и исходным кодом.'),
          'Memory Allocation (Распределение памяти)': CategoryDetail([],
              'Инструмент распределения памяти позволяет разработчикам отслеживать использование памяти их приложениями, что помогает выявлять утечки памяти и оптимизировать ресурсы.\nФункции:\n\t\t*Отслеживание использования памяти: Позволяет видеть, сколько памяти использует приложение, и анализировать, как она распределяется между различными объектами и виджетами.\n\t\t*Профилирование: Помогает выявить узкие места в использовании памяти, позволяя разработчикам оптимизировать код для снижения потребления ресурсов.\n\t\t*Анализ объектов: Предоставляет возможность видеть, какие объекты занимают память и когда они освобождаются, что способствует улучшению общей производительности приложения.'),
        },
        'Internationalization (Интернационализация)': {
          'Localization Package': CategoryDetail([
            'inltl',
            'Easy_localization',
          ],
              'Localization Package (Пакет локализации)\n\nПакет локализации в Flutter предоставляет разработчикам инструменты для поддержки многозначных языков и культур, позволяя приложениям быть доступными и понятными для пользователей из разных регионов. Он помогает управлять текстами, переводами и другими локализованными ресурсами.\n\nОсновные функции\n\n\t\t*Переводы: Пакет позволяет разработчикам легко управлять переводами текстов для различных языков, что позволяет пользователям выбирать предпочитаемый язык интерфейса.\n\t\t*Управление ресурсами: Локализация пакета включает в себя возможность работы с изображениями, аудиофайлами и другими ресурсами, которые могут различаться в зависимости от языка.\n\t\t*Форматирование: Пакет поддерживает автоматическое форматирование дат, чисел и валют в соответствии с локальными стандартами, улучшая взаимодействие пользователя с приложением.\n\t\t*Легкость интеграции: Пакет легко интегрируется в существующие приложения и предоставляет понятный API для работы с локализацией.\n\nИспользуемые пакеты\n\t\t*easy_localization — это мощный пакет, который упрощает процесс локализации приложений на Flutter. Он предлагает удобный API для работы с переводами и поддерживает как JSON, так и ARB файлы.\n\t\t*intl: Пакет intl используется для форматирования дат, чисел и строк с учетом локальных стандартов, что делает его незаменимым для интернационализации.'),
          'Transition': CategoryDetail(
            ['Google Sheet (Google таблицы)', 'Localizely', 'POEditor'],
            'Google Sheets (Google таблицы)\n\nGoogle Sheets — это облачный сервис для работы с таблицами, который позволяет командам эффективно сотрудничать в процессе локализации. Локализаторы могут легко вносить изменения, добавлять переводы и отслеживать версионность.\n\nОсновные функции:\n\t\t*Совместная работа в реальном времени с другими участниками проекта.\n\t\t*Поддержка формул и функций для автоматизации задач локализации.\n\t\t*Легкий экспорт данных в различных форматах для интеграции с приложением.\n\nПрименение в приложении: Google Sheets может быть использован для хранения текстов локализации, где разработчики могут добавлять строки для перевода, а локализаторы смогут легко редактировать их.\n\nLocalizely\n\nLocalizely — это платформа, ориентированная на локализацию приложений и веб-сайтов, предлагающая инструменты для управления переводами и интеграции с существующими проектами.\n\nОсновные функции:\n\t\t*Интуитивно понятный интерфейс для управления проектами локализации.\n\t\t*Поддержка автоматических переводов и инструменты для их редактирования.\n\t\t*Интеграция с популярными фреймворками и библиотеками для упрощения рабочего процесса.\nПрименение в приложении: Localizely позволяет командам локализации эффективно управлять переводами и поддерживать актуальность текстов в приложении.\n\nPOEditor \n\nPOEditor — это онлайн-платформа для управления переводами, которая позволяет командам сотрудничать в процессе локализации, предоставляя инструменты для импорта и экспорта строк, а также для работы с переводами.\nОсновные функции:\n\t\t*Легкий импорт и экспорт текстов локализации в различных форматах, включая CSV и XLIFF.\n\t\t*Инструменты для автоматизации переводов, такие как Machine Translation (машинный перевод).\n\t\t*Удобный интерфейс для отслеживания прогресса переводов и управления задачами.\n\nПрименение в приложении: POEditor может использоваться для централизованного управления переводами, обеспечивая быструю и эффективную локализацию приложений на различных языках.',
          )
        },
        'Analytics (Аналитика)': {
          'Google Analytics (Google аналитика)': CategoryDetail([],
              'Инструменты аналитики в мобильных приложениях позволяют собирать, анализировать и интерпретировать данные о поведении пользователей, производительности, взаимодействиях и других метриках. Эти данные помогают принимать обоснованные решения, улучшать интерфейсы, повышать конверсию и оптимизировать пользовательский опыт.\n\nОсновные инструменты и метрики для аналитики:\n\nFirebase Analytics\n\nБесплатный инструмент от Google, оптимизированный для мобильных приложений. Firebase Analytics предоставляет данные о взаимодействии пользователей, сеансах, демографических показателях и многом другом.\nОсновные функции:\n\t\t*Отслеживание событий (например, нажатий, переходов между экранами).\n\t\t*Поддержка расширенной аналитики для углубленного анализа поведения.\n\t\t*Интеграция с другими инструментами Firebase для A/B-тестирования, мониторинга производительности и уведомлений.\n\nFirebase Analytics позволяет отслеживать ключевые показатели (KPIs), такие как удержание пользователей, конверсии, активные пользователи, а также выявлять слабые места в интерфейсе.\n\nGoogle Analytics for Mobile\n\nПопулярный аналитический инструмент для отслеживания поведения пользователей в приложениях и веб-сайтах. Google Analytics дает широкий обзор аудитории, источников трафика и данных об активностях.\n\nОсновные функции:\n\t\t*Сегментация аудитории и отслеживание воронок конверсий.\n\t\t*Возможность построения индивидуальных отчетов.\n\t\t*Отчеты в реальном времени.\n\nGoogle Analytics используется для комплексного анализа пользовательских данных и построения прогнозов, что помогает улучшить целевые страницы и удержание пользователей.'),
          'FireBase Analytics (Аналитика Firebase )': CategoryDetail([],
              'Инструменты аналитики в мобильных приложениях позволяют собирать, анализировать и интерпретировать данные о поведении пользователей, производительности, взаимодействиях и других метриках. Эти данные помогают принимать обоснованные решения, улучшать интерфейсы, повышать конверсию и оптимизировать пользовательский опыт.\n\nОсновные инструменты и метрики для аналитики:\n\nFirebase Analytics\n\nБесплатный инструмент от Google, оптимизированный для мобильных приложений. Firebase Analytics предоставляет данные о взаимодействии пользователей, сеансах, демографических показателях и многом другом.\nОсновные функции:\n\t\t*Отслеживание событий (например, нажатий, переходов между экранами).\n\t\t*Поддержка расширенной аналитики для углубленного анализа поведения.\n\t\t*Интеграция с другими инструментами Firebase для A/B-тестирования, мониторинга производительности и уведомлений.\n\nFirebase Analytics позволяет отслеживать ключевые показатели (KPIs), такие как удержание пользователей, конверсии, активные пользователи, а также выявлять слабые места в интерфейсе.\n\nGoogle Analytics for Mobile\n\nПопулярный аналитический инструмент для отслеживания поведения пользователей в приложениях и веб-сайтах. Google Analytics дает широкий обзор аудитории, источников трафика и данных об активностях.\n\nОсновные функции:\n\t\t*Сегментация аудитории и отслеживание воронок конверсий.\n\t\t*Возможность построения индивидуальных отчетов.\n\t\t*Отчеты в реальном времени.\n\nGoogle Analytics используется для комплексного анализа пользовательских данных и построения прогнозов, что помогает улучшить целевые страницы и удержание пользователей.'),
        },
        'Deployment (Развертывание)': {
          'Play Store': CategoryDetail([],
              'Play Store\nПлатформа для распространения приложений на Android. Google Play Store позволяет разработчикам публиковать приложения, которые затем становятся доступны для загрузки пользователям Android-устройств по всему миру. В Play Store также есть система для анализа отзывов, предоставления обновлений и отслеживания метрик. Требует подписки на аккаунт Google Play Console и соблюдения политики Google для приложений.'),
          'App Store': CategoryDetail([],
              'App Store\nМагазин приложений от Apple, предназначенный для устройств на iOS. App Store требует, чтобы разработчики соответствовали строгим требованиям безопасности и качества, а также подписали приложение цифровым сертификатом. Процесс публикации проходит через App Store Connect, и рассмотрение приложения может занять несколько дней. Включает инструменты для управления обновлениями, отзывами и аналитикой'),
          'Other': CategoryDetail([],
              'Other\nСуществуют и альтернативные площадки для распространения мобильных приложений, такие как Amazon Appstore, Samsung Galaxy Store или Huawei AppGallery. Эти магазины также предлагают платформы для публикации и распространения приложений, но требования и процесс публикации могут отличаться от Google Play и App Store.'),
        }
      }),*/
  LanguagesEntity(
      image: 'assets/images/ReactImage.svg',
      title: 'Using the React Library',
      description: 'Create the web interfaces of the future with dynamic and responsive design.'),
  LanguagesEntity(
      image: 'assets/images/JavaImage.svg',
      title: 'Programming in Java',
      description: 'Create reliable solutions for web, server, and enterprise systems that are scalable.'),
];
